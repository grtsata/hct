<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>魔塔召喚戦記 (改 v3.9.9 - 重複宣言修正・4カラム調整)</title>
    <style>
        /* --- 基本スタイル (変更なし) --- */
        :root {
            --bg-dark: #1a1f25; --bg-mid: #2c3e50; --bg-light: #4a637a;
            --text-light: #e1e8f0; --text-mid: #88a1b9; --text-dark: #4f5660;
            --accent-red: #e74c3c; --accent-green: #2ecc71; --accent-blue: #3498db;
            --accent-yellow: #f1c40f; --accent-purple: #9b59b6; --accent-orange: #e67e22;
            --border-color: #10151a;
            --hp-high: #2ecc71; --hp-mid: #f1c40f; --hp-low: #e74c3c;
            --font-main: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            --transition-speed: 0.3s;
            --stone-color: #8e44ad;
        }
        html, body { height: 100%; margin: 0; padding: 0; overflow: hidden; font-size: 15px; }
        body { font-family: var(--font-main); display: flex; flex-direction: column; background-color: var(--bg-dark); color: var(--text-light); }
        h1, h2, h3, h4, h5 { text-align: center; margin-top: 0; margin-bottom: 15px; color: var(--text-mid); font-weight: 500;}
        h1 { color: var(--accent-red); margin-bottom: 10px; font-size: 1.8em; }
        h2 { font-size: 1.4em; } h3 { font-size: 1.2em; } h4 { font-size: 1.1em; }
        button { cursor: pointer; border: none; border-radius: 5px; padding: 10px 18px; font-size: 1em; transition: all var(--transition-speed) ease; font-weight: bold; background-color: var(--accent-blue); color: white; }
        button:hover:not(:disabled) { transform: translateY(-2px); filter: brightness(1.15); box-shadow: 0 3px 6px rgba(0,0,0,0.2); }
        button:active:not(:disabled) { transform: translateY(0px); filter: brightness(1.05); box-shadow: 0 1px 3px rgba(0,0,0,0.15); }
        button:disabled { cursor: not-allowed; opacity: 0.5; transform: none; background-color: var(--text-dark) !important; color: var(--bg-light) !important; box-shadow: none; filter: grayscale(50%); }
        ul { list-style: none; padding: 0; margin: 0; }
        .container { background-color: var(--bg-mid); padding: 15px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.2); border: 1px solid var(--border-color); transition: opacity var(--transition-speed) ease, transform var(--transition-speed) ease; display: flex; flex-direction: column; flex-shrink: 0; /* 基本は縮まない */ }
        .hidden { display: none !important; }

        /* --- 画面遷移アニメーション (変更なし) --- */
        .screen-content, #reward-modal, #result-screen { opacity: 0; transform: translateY(10px); transition: opacity var(--transition-speed) ease, transform var(--transition-speed) ease; pointer-events: none; }
        .screen-content.active, #reward-modal.active, #result-screen.active { opacity: 1; transform: translateY(0); pointer-events: auto; }
        #reward-modal:not(.active), #result-screen:not(.active) { display: none; }

        /* --- 全体レイアウト (変更) --- */
        #game-header { padding: 5px 15px; background-color: #10151a; flex-shrink: 0; position: relative; z-index: 10; }
        #game-info-header { display: none; justify-content: space-around; align-items: center; flex-wrap: wrap; font-size: 0.9em; color: var(--text-mid); min-height: 30px; }
        #game-info-header.active { display: flex; }
        #game-info-header span { margin: 2px 6px; white-space: nowrap; cursor: help; }
        #game-info-header strong { color: var(--accent-yellow); font-size: 1.05em; }
        #magic-stone-info strong { color: var(--stone-color); }

        #game-wrapper {
            display: grid;
            grid-template-columns: repeat(4, 1fr); /* デフォルトは均等割り */
            gap: 15px; /* カラム間のギャップを少し広げる */
            padding: 15px; /* 全体のパディングも少し広げる */
            flex-grow: 1;
            overflow: hidden;
        }
        /* 戦闘画面のみカラム幅を変更 (4カラム時) */
        #battle-screen.active {
             grid-template-columns: 1fr 2fr 2fr 1.5fr; /* Col1: 1, Col2: 2, Col3: 2, Col4: 1.5 */
        }

        .column {
            display: flex;
            flex-direction: column;
            gap: 15px; /* カラム内の要素間ギャップも調整 */
            min-width: 0;
            overflow-y: auto; /* 基本的にはスクロールさせないが、念のため */
            /* スクロールバーのデザイン（任意） */
            scrollbar-width: thin;
            scrollbar-color: var(--bg-light) var(--bg-mid);
        }
        .column::-webkit-scrollbar { width: 8px; }
        .column::-webkit-scrollbar-track { background: var(--bg-mid); border-radius: 4px; }
        .column::-webkit-scrollbar-thumb { background-color: var(--bg-light); border-radius: 4px; border: 2px solid var(--bg-mid); }


        /* --- 各画面の基本スタイル (変更なし) --- */
        .screen-content { width: 100%; height: 100%; overflow-y: auto; display: none; flex-direction: column; grid-column: 1 / -1; grid-row: 1; }
        .screen-content.active { display: flex; }
        /* Grid content screens */
        #hub-screen.screen-content.active,
        #summon-contract-screen.screen-content.active,
        #party-編成-screen.screen-content.active,
        #battle-screen.screen-content.active { display: contents; }

        /* フレーバー表示エリア (カラム4内) (変更なし) */
        #column4-flavor-area {
            background-color: var(--bg-dark); border: 1px solid var(--border-color); border-radius: 6px;
            padding: 8px 12px; flex-shrink: 0; /* 高さは固定 */
            min-height: 50px;
            display: none;
            flex-direction: column; justify-content: center;
            cursor: pointer;
            /* margin-bottom は column の gap で管理 */
        }
        #column4-flavor-area.active { display: flex; }
        #column4-flavor-area h5 { margin: 0 0 3px 0; font-size: 0.85em; color: var(--accent-purple); text-align: left; font-weight: bold; }
        #column4-flavor-text { font-size: 0.9em; color: var(--text-mid); font-style: italic; line-height: 1.4; animation: flicker 3s infinite alternate; }
        @keyframes flicker { 0%, 100% { opacity: 0.9; } 50% { opacity: 1; text-shadow: 0 0 2px rgba(225, 232, 240, 0.3); } }

        /* --- タイトル画面 (変更なし) --- */
        #title-screen { justify-content: center; align-items: center; text-align: center; }
        #title-screen h1 { font-size: 2.2em; margin-bottom: 10px; color: var(--text-mid); }
        #title-screen .subtitle { font-size: 1.1em; color: var(--accent-yellow); margin-bottom: 20px; }
        #title-screen .story { max-width: 550px; margin: 0 auto 25px auto; color: var(--text-light); line-height: 1.6; font-size: 0.9em;}
        #highest-floor-display { margin-top: 15px; font-size: 1em; color: var(--text-mid); }
        #title-buttons { display: flex; flex-direction: column; align-items: center; gap: 15px; margin-top: 20px; }
        #start-game-button, #continue-game-button { width: 200px; font-size: 1.1em; padding: 12px 0; }
        #start-game-button { background-color: var(--accent-green); color: white; } #start-game-button:hover { background-color: #27ae60; }
        #continue-game-button { background-color: var(--accent-blue); color: white; } #continue-game-button:hover { background-color: #2980b9; }

        /* --- 拠点画面 (4カラム対応, 高さ調整) --- */
        #hub-screen-col1 { grid-column: 1; display: none; }
        #hub-screen-col2 { grid-column: 2; display: none; }
        #hub-screen-col3 { grid-column: 3; display: none; }
        #hub-screen-col4 { grid-column: 4; display: none; }
        #hub-screen.active #hub-screen-col1,
        #hub-screen.active #hub-screen-col2,
        #hub-screen.active #hub-screen-col3,
        #hub-screen.active #hub-screen-col4 { display: flex; }

        #hub-screen-col2 .container { /* ボタンコンテナ */
            justify-content: center;
            align-items: center;
            height: 100%; /* ボタンが少ないので中央揃えで高さいっぱい */
        }
        #hub-buttons { display: flex; flex-direction: column; align-items: center; gap: 20px; width: 100%; padding: 20px 0;}
        #hub-buttons button { width: 90%; max-width: 250px; font-size: 1.2em; padding: 15px 0; }
        #hub-party-button { background-color: var(--accent-green); } #hub-party-button:hover { background-color: #27ae60; }
        #hub-summon-button { background-color: var(--accent-purple); } #hub-summon-button:hover { background-color: #8e44ad; }
        #hub-challenge-button { background-color: var(--accent-red); } #hub-challenge-button:hover:not(:disabled) { background-color: #c0392b; }

        #hub-screen-col3 > .container { /* パーティリストのコンテナ */
            flex-grow: 1; /* カラムの高さいっぱいまで伸びる */
            display: flex; /* 中身の配置のため */
            flex-direction: column; /* 中身の配置のため */
            overflow: hidden; /* リストのスクロールは ul で行う */
        }
        #hub-current-party-display { /* パーティリストのラッパー */
            /* 既存スタイルには padding, bg-color, border-radius, width, flex-grow, overflow-y, display, flex-direction, align-items がある */
            /* コンテナ内で高さを伸ばす */
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        #hub-current-party-display h4 { /* 変更なし */ flex-shrink: 0; }
        #hub-party-list { /* ul要素 */
            display: flex; flex-direction: column; gap: 8px; width: 100%; padding: 0 10px; box-sizing: border-box;
            flex-grow: 1; /* タイトル以外のスペースを埋める */
            overflow-y: auto; /* スクロール */
            min-height: 0; /* flex縮小問題回避 */
        }
        #hub-party-list li { font-size: 0.9em; background-color: var(--bg-mid); padding: 8px 12px; border-radius: 4px; display: flex; align-items: center; gap: 6px; cursor: pointer; transition: background-color 0.2s, border-color 0.2s; border: 1px solid var(--border-color); }
        #hub-party-list li:hover { background-color: var(--bg-dark); }
        #hub-party-list li.selected-in-detail { border-color: var(--accent-yellow) !important; background-color: #5a7086 !important; }
        #hub-party-list li .icon { font-size: 1em; margin-right: 4px;}
        #hub-party-list li .name { flex-grow: 1; }
        #hub-party-list li .level { margin-left: auto; color: var(--text-mid); }

        #hub-screen-col4 > #hub-details-panel { /* 詳細パネル */
            flex-grow: 1; /* カラム内でフレーバーエリア以外の高さを占める */
            min-height: 200px; /* 最小高さを維持 */
        }

        /* --- 召喚契約画面 (4カラム対応, 高さ調整) --- */
        #summon-contract-screen-col1 { grid-column: 1 / span 2; display: none; }
        #summon-contract-screen-col3 { grid-column: 3; display: none; }
        #summon-contract-screen-col4 { grid-column: 4; display: none; }
        #summon-contract-screen.active #summon-contract-screen-col1,
        #summon-contract-screen.active #summon-contract-screen-col3,
        #summon-contract-screen.active #summon-contract-screen-col4 { display: flex; }

        #summon-contract-screen-col1 > .container { /* リストのコンテナ */
            flex-grow: 1; /* カラムの高さいっぱいまで伸びる */
            display: flex; /* 念のため */
            flex-direction: column; /* 念のため */
            overflow: hidden; /* リストのスクロールは内部で行う */
        }
        #summon-list-container { /* リスト自体のラッパー */
            flex-grow: 1; /* コンテナ内でタイトル以外の高さを占める */
            overflow-y: auto; /* スクロールはこちらで */
            min-height: 0; /* flex縮小問題回避 */
            width: 100%; background-color: var(--bg-light); padding: 15px; border-radius: 8px; border: 1px solid var(--border-color); display: flex; flex-direction: column; gap: 10px;
        }
        .summon-list-item { display: flex; justify-content: space-between; align-items: center; background-color: var(--bg-mid); padding: 10px 15px; border-radius: 6px; border: 1px solid var(--border-color); cursor: pointer; transition: background-color 0.2s, border-color 0.2s; }
        .summon-list-item:hover { background-color: var(--bg-dark); }
        .summon-list-item.selected-in-detail { border-color: var(--accent-yellow) !important; background-color: #5a7086 !important; }
        .summon-list-item span:first-child { display: flex; align-items: center; gap: 8px; font-weight: bold; font-size: 1.05em; flex-grow: 1; }
        .summon-list-item .summon-cost { display: flex; align-items: center; gap: 5px; }
        .summon-list-item .summon-cost strong { color: var(--stone-color); }
        .summon-list-item button { padding: 6px 12px; font-size: 0.9em; background-color: var(--accent-green); flex-shrink: 0; }
        .summon-list-item button:hover:not(:disabled) { background-color: #27ae60; }
        #summon-list-placeholder { text-align: center; color: var(--text-mid); margin: auto; /* 中央寄せに変更 */ }

        #summon-contract-screen-col3 > #summon-details-panel { /* 詳細パネル */
            flex-grow: 1; /* カラムの高さいっぱいまで伸びる */
            min-height: 200px; /* 最小高さを維持 */
        }

        #summon-contract-screen-col4 {
            display: flex; /* 縦方向の配置のため */
            flex-direction: column; /* 縦方向の配置のため */
            justify-content: space-between; /* フレーバーを上、ボタン類を下に */
        }
        #summon-contract-screen-col4 > #column4-flavor-area {
            flex-shrink: 0; /* 既存だが確認 */
        }
        #summon-contract-screen-col4 > .container:last-child { /* ボタン類を含むコンテナ */
            margin-top: auto; /* 自動で上に押し上げる (既存の指定だが確認) */
            flex-shrink: 0; /* 縮まないように */
            width: 100%; /* 幅をコンテナに合わせる */
        }
        #summon-resource-info { margin-bottom: 20px; font-size: 1.1em; text-align: center; padding: 10px; background-color: var(--bg-light); border-radius: 6px; }
        #summon-resource-info strong { color: var(--stone-color); font-weight: bold; }
        #back-to-hub-button { display: block; width: 100%; margin-top: auto; background-color: var(--accent-blue); } /* margin-top: auto */
        #back-to-hub-button:hover { background-color: #2980b9; }

        /* --- パーティ編成画面 (変更, 高さ調整) --- */
        #party-編成-screen-col1 { grid-column: 1; display: none; }
        #party-編成-screen-col2 { grid-column: 2; display: none; }
        #party-編成-screen-col3 { grid-column: 3; display: none; }
        #party-編成-screen-col4 { grid-column: 4; display: none; }
        #party-編成-screen.active #party-編成-screen-col1,
        #party-編成-screen.active #party-編成-screen-col2,
        #party-編成-screen.active #party-編成-screen-col3,
        #party-編成-screen.active #party-編成-screen-col4 { display: flex; }

        .編成-column-title { color: var(--text-light); font-size: 1.1em; border-bottom: 1px solid var(--bg-light); padding-bottom: 8px; margin-bottom: 10px; flex-shrink: 0; text-align: left; }

        #party-編成-screen-col1 > .container,
        #party-編成-screen-col2 > .container { /* プールとパーティリストのコンテナ */
             flex-grow: 1; /* カラムの高さいっぱいまで伸びる */
             display: flex;
             flex-direction: column;
             overflow: hidden; /* リストのスクロールは内部で */
        }
        #monster-pool-list-container,
        #current-party-list-container { /* リストのラッパー */
            flex-grow: 1; /* 各コンテナ内でタイトル以外の高さを占める */
            overflow-y: auto; /* スクロールはこちらで */
            min-height: 150px; /* 最小高さは維持 */
            background-color: var(--bg-light); padding: 10px; border-radius: 6px; border: 1px solid var(--border-color); display: flex; flex-direction: column; gap: 8px;
        }
        .monster-list-item { display: flex; align-items: center; justify-content: space-between; padding: 7px 10px; background-color: var(--bg-mid); border-radius: 4px; cursor: pointer; transition: background-color 0.2s, border-color 0.2s, transform 0.1s; border: 1px solid var(--border-color); }
        .monster-list-item:hover { background-color: #5c7b97; transform: scale(1.02); }
        .monster-list-item.selected-in-detail { border-color: var(--accent-yellow) !important; background-color: #5a7086 !important; transform: scale(1.03); }
        .monster-list-item.selected-for-party { border-color: var(--accent-green); background-color: #507f6f; }
        .monster-list-item .list-icon { display: inline-block; width: 1.2em; text-align: center; margin-right: 4px; }
        .monster-list-item span:first-child { font-weight: bold; flex-grow: 1; margin-right: 8px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; font-size: 0.95em; display: flex; align-items: center; }
        .monster-list-item .level { font-size: 0.8em; color: var(--text-mid); margin-left: auto; margin-right: 8px; white-space: nowrap; }
        .add-remove-btn { padding: 4px 8px; font-size: 0.8em; margin-left: 5px; border-radius: 3px; flex-shrink: 0; }
        .add-btn { background-color: var(--accent-green); color: white; } .remove-btn { background-color: var(--accent-red); color: white; }

        #party-編成-screen-col3 > #party-details-panel { /* 詳細パネル */
             flex-grow: 1; /* カラムの高さいっぱいまで伸びる */
             min-height: 200px; /* 最小高さを維持 */
        }

        #party-編成-screen-col4 {
            display: flex; /* 縦方向の配置のため */
            flex-direction: column; /* 縦方向の配置のため */
            justify-content: space-between; /* フレーバーを上、ボタンを下に */
        }
        #party-col4-buttons { /* ボタンのラッパー */
            flex-shrink: 0; /* 縮まないように */
            margin-top: auto; /* 上に押し上げる */
            display: flex; flex-direction: column; gap: 10px; /* 既存のgap */
        }
        #confirm-party-button { display: block; width: 100%; background-color: var(--accent-green); margin-top: 0; } /* margin-top: auto; を削除 */
        #confirm-party-button:hover:not(:disabled) { background-color: #27ae60; }

         /* --- 出撃準備完了画面 (変更なし) --- */
         #ready-to-start-screen { text-align: center; justify-content: center; align-items: center; }
         #ready-to-start-screen h2 { color: var(--accent-blue); font-size: 1.5em; margin-bottom: 15px;}
         #ready-party-summary { margin: 20px 0; }
         #ready-party-summary h4 { font-size: 1.2em; color: var(--text-mid); margin-bottom: 15px; }
         #ready-party-summary ul { display: flex; justify-content: center; gap: 15px; flex-wrap: wrap;}
         #ready-party-summary li { background-color: var(--bg-light); padding: 8px 15px; border-radius: 5px; font-weight: bold; color: var(--text-light); border: 1px solid var(--border-color); display: flex; align-items: center; gap: 5px;}
         #ready-screen-buttons { display: flex; flex-direction: column; align-items: center; gap: 15px; margin-top: 25px;}
         #start-first-wave-button { background-color: var(--accent-red); color: white; font-size: 1.2em; padding: 12px 25px; width: 220px; }
         #start-first-wave-button:hover { background-color: #c0392b; }
         #back-to-hub-from-ready-button { background-color: var(--accent-blue); font-size: 1em; padding: 10px 20px; width: 180px; }
         #back-to-hub-from-ready-button:hover { background-color: #2980b9; }

        /* --- セットアップ画面 (変更なし) --- */
        #setup-phase { justify-content: center; align-items: center; }
        #setup-phase h2 { color: var(--accent-green); font-size: 1.3em; }
        #enemy-preview { margin-bottom: 20px; padding: 15px; background-color: var(--bg-light); border-radius: 6px; max-width: 80%; }
        #enemy-preview h3 { margin: 0 0 10px 0; color: var(--accent-red); font-size: 1.1em; }
        #enemy-list { display: flex; flex-wrap: wrap; gap: 8px; justify-content: center; font-size: 0.9em; }
        #enemy-list span { background-color: var(--bg-mid); padding: 4px 8px; border-radius: 4px; border: 1px solid var(--text-dark); display: flex; align-items: center; gap: 4px;}
        #start-battle-button { background-color: var(--accent-green); color: white; display: block; margin: 25px auto 0 auto; width: 200px; font-size: 1.1em;}
        #start-battle-button:hover { background-color: #27ae60; }

        /* --- バトル画面 (変更, 高さ調整) --- */
        #battle-screen-col1 { grid-column: 1; display: none; }
        #battle-screen-col2 { grid-column: 2; display: none; }
        #battle-screen-col3 { grid-column: 3; display: none; }
        #battle-screen-col4 { grid-column: 4; display: none; }
        #battle-screen.active #battle-screen-col1,
        #battle-screen.active #battle-screen-col2,
        #battle-screen.active #battle-screen-col3,
        #battle-screen.active #battle-screen-col4 { display: flex; }

        /* Col1: パーティ情報と詳細パネル */
        #party-info { /* パーティ情報 */
            padding: 10px; background-color: var(--bg-mid); border: 1px solid var(--border-color); border-radius: 6px;
            flex-shrink: 0; /* 高さは固定 */
            max-height: 200px; /* は既存 */
            overflow-y: auto;
        }
        #party-info h3 { color: var(--accent-blue); font-size: 1.05em; margin-bottom: 8px; border-bottom: 1px solid var(--bg-light); padding-bottom: 5px; text-align: left;}
        #party-info-list { display: flex; flex-direction: column; gap: 4px; }
        .party-member-summary { display: flex; align-items: center; font-size: 0.8em; cursor: pointer; padding: 4px 6px; border-radius: 4px; transition: background-color 0.2s;}
        .party-member-summary:hover { background-color: var(--bg-light); }
        .party-member-summary.dead { opacity: 0.6; filter: grayscale(50%); }
        .party-member-summary .icon { margin-right: 4px; font-size: 1em; width: 1em; text-align: center;}
        .party-member-summary .name { flex-grow: 1; margin-right: 5px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-weight: 500;}
        .party-member-summary .hp { font-size: 0.9em; color: var(--text-mid); white-space: nowrap; margin-left: 5px;}
        .party-hp-bar-container { width: 50px; height: 6px; background-color: var(--bg-dark); border-radius: 3px; overflow: hidden; margin-left: 5px; border: 1px solid #111; flex-shrink: 0;}
        .party-hp-bar { height: 100%; transition: width 0.3s ease-out, background-color 0.3s ease; }
        .party-hp-bar.high { background-color: var(--hp-high); }
        .party-hp-bar.mid { background-color: var(--hp-mid); }
        .party-hp-bar.low { background-color: var(--hp-low); }

        #selected-char-details-battle { /* 詳細パネル */
            flex-grow: 1; /* カラム内の残りのスペースを埋める */
            min-height: 150px; /* 最小高さを確保 */
            /* .detail-panel-container のスタイルを継承 */
            /* hidden クラスで初期非表示 (JSで制御) */
        }
        /* 詳細パネル共通スタイルは後述 */

        /* Col2 & Col3: 戦闘エリア */
        #battle-area-player, #battle-area-opponent {
            background-color: var(--bg-mid); padding: 10px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            height: 100%; /* カラムの高さいっぱいを使う */
            display: flex; flex-direction: column; overflow: hidden;
        }
        #battle-area-player h4, #battle-area-opponent h4 {
            text-align:left; margin-bottom: 5px; color: var(--accent-blue); flex-shrink: 0; /* タイトルは縮まない */
        }
        #battle-area-opponent h4 { color: var(--accent-red); }

        .party-area { /* キャラクターカードが入るエリア */
            display: flex; flex-wrap: wrap; justify-content: flex-start; align-content: flex-start; gap: 8px; padding: 10px; border: 1px dashed var(--text-dark); border-radius: 6px; background-color: var(--bg-light);
            min-height: 150px; /* 最小高さ */
            flex-grow: 1; /* コンテナ内の残りの高さを埋める */
            overflow-y: auto; /* カードが多い場合にスクロール */
            scrollbar-width: thin;
            scrollbar-color: var(--bg-dark) var(--bg-light);
        }
        .party-area::-webkit-scrollbar { width: 6px; }
        .party-area::-webkit-scrollbar-track { background: var(--bg-light); border-radius: 3px; }
        .party-area::-webkit-scrollbar-thumb { background-color: var(--bg-dark); border-radius: 3px; border: 1px solid var(--bg-light); }

        .character-card { border: 2px solid var(--border-color); padding: 6px; border-radius: 6px; background-color: var(--bg-light); width: calc(50% - 8px); min-width: 110px; box-sizing: border-box; text-align: center; transition: all 0.15s ease; position: relative; display: flex; flex-direction: column; box-shadow: 0 1px 3px rgba(0,0,0,0.15); cursor: pointer; }
        .party-area.many-units .character-card { width: calc(33.33% - 8px); min-width: 90px; }
        .party-area.very-many-units .character-card { width: calc(25% - 8px); min-width: 80px; font-size: 0.9em; }
        .character-card.selected-in-detail { border-color: var(--accent-yellow) !important; box-shadow: 0 0 8px 2px var(--accent-yellow); }
        .character-card:hover { transform: translateY(-2px) scale(1.02); border-color: var(--accent-blue); z-index: 2; }
        .character-card.dead { opacity: 0.4; background-color: #566573; box-shadow: none; transform: scale(0.95); cursor: default; filter: grayscale(80%); border-color: var(--border-color) !important; }
        .character-card.active { animation: active-border-pulse 1s infinite ease-in-out; box-shadow: 0 0 10px 3px var(--accent-yellow); z-index: 5; transform: scale(1.05); }
        @keyframes active-border-pulse { 0% { border-color: var(--accent-yellow); } 50% { border-color: var(--text-light); } 100% { border-color: var(--accent-yellow); } }
        .char-name { font-weight: 500; font-size: 0.8em; margin-bottom: 3px; color: var(--accent-red); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; } .char-name .level { font-size: 0.9em; color: var(--text-mid); font-weight: normal; margin-left: 2px;}
        #battle-screen-col2 .char-name { color: var(--accent-blue); }
        .traits-icons { min-height: 14px; margin-bottom: 3px; display: flex; justify-content: center; gap: 3px; flex-wrap: wrap;} .trait-icon { font-size: 0.75em; padding: 1px 4px; border-radius: 3px; color: white; background-color: var(--accent-purple); cursor: help; }
        .hp-bar-container { background-color: var(--bg-dark); border-radius: 4px; height: 7px; margin-bottom: 3px; overflow: hidden; border: 1px solid #111; } .hp-bar { height: 100%; width: 100%; transition: width 0.3s ease-out, background-color 0.3s ease; border-radius: 3px; } .hp-bar.high { background-color: var(--hp-high); } .hp-bar.mid { background-color: var(--hp-mid); } .hp-bar.low { background-color: var(--hp-low); }
        .char-hp { font-size: 0.65em; color: var(--text-mid); margin-bottom: 3px; }
        .status-icons { min-height: 14px; margin-bottom: 2px; display: flex; justify-content: center; gap: 3px; flex-wrap: wrap;} .status-icon { font-size: 0.75em; padding: 1px 4px; border-radius: 3px; color: white; cursor: help; } .icon-poison { background-color: #8e44ad; animation: pulse-purple 1.5s infinite; } .icon-burn { background-color: var(--accent-orange); animation: pulse-orange 1.5s infinite; } .icon-curse { background-color: #5a4a6e; animation: pulse-dark 1.8s infinite; } .icon-def_down { background-color: var(--accent-blue); opacity: 0.8; } .icon-atk_up { background-color: var(--accent-yellow); font-weight: bold; } .icon-def_up { background-color: var(--accent-green); font-weight: bold; } .icon-sleep { background-color: #1abc9c; animation: pulse-cyan 2s infinite ease-in-out; } .icon-paralysis { background-color: #f39c12; animation: shake-slight 0.5s infinite linear; } .icon-protected { background-color: #bdc3c7; } .icon-temp_atk_up, .icon-temp_fire_up { background-color: var(--accent-yellow); opacity: 0.8; border: 1px dashed white;}
        @keyframes pulse-purple { 0%, 100% { filter: brightness(1); } 50% { filter: brightness(1.3); } } @keyframes pulse-orange { 0%, 100% { filter: brightness(1); } 50% { filter: brightness(1.3); } } @keyframes pulse-dark { 0%, 100% { opacity: 0.8; } 50% { opacity: 1; } } @keyframes pulse-cyan { 0%, 100% { transform: scale(1); } 50% { transform: scale(0.9); } } @keyframes shake-slight { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-1px); } 75% { transform: translateX(1px); } }
        .damage-popup { position: absolute; top: -14px; left: 50%; transform: translateX(-50%); padding: 2px 5px; border-radius: 4px; font-size: 0.8em; font-weight: bold; color: white; white-space: nowrap; pointer-events: none; animation: popup-animation 0.8s ease-out forwards; z-index: 10; text-shadow: 1px 1px 2px rgba(0,0,0,0.5); } .damage-popup.damage { background-color: rgba(231, 76, 60, 0.9); } .damage-popup.heal { background-color: rgba(46, 204, 113, 0.9); } .damage-popup.miss { background-color: rgba(149, 165, 166, 0.9); font-size: 0.7em; } .damage-popup.critical { background-color: rgba(241, 196, 15, 0.95); font-size: 0.9em; font-weight: bolder; }
        @keyframes popup-animation { 0% { transform: translate(-50%, 0) scale(1); opacity: 1; } 100% { transform: translate(-50%, -35px) scale(0.8); opacity: 0; } }
        .taking-damage { animation: shake 0.15s ease-in-out; } @keyframes shake { 0%, 100% { transform: translateX(0) scale(1.03); } 33% { transform: translateX(-3px) scale(1.03); } 66% { transform: translateX(3px) scale(1.03); } }

        /* Col4: フレーバー、ログ、ボタン */
        #battle-screen-col4 > #column4-flavor-area {
             flex-shrink: 0; /* 既存だが確認 */
        }
        #log-area-container { /* ログエリアのコンテナ */
            padding: 10px;
            background-color: var(--bg-mid);
            display: flex; /* OK */
            flex-direction: column; /* OK */
            overflow: hidden; /* OK: Container自体はスクロールしない */
            border-radius: 6px;
            border: 1px solid var(--border-color);
            flex-grow: 1; /* OK: カラム内で伸びる */
            min-height: 150px; /* OK: 最小高さを確保 */
        }
        #log-area-container h3 {
            flex-shrink: 0; /* OK: タイトルは縮まない */
            margin: 0 0 8px 0;
            font-size: 1.05em;
            color: var(--text-mid);
            border-bottom: 1px solid var(--bg-light);
            padding-bottom: 5px;
            text-align: left;
        }
        #log-area {
            flex-grow: 1; /* OK: Container内の残りのスペースを埋める */
            overflow-y: auto; /* OK: 内容がはみ出たらスクロールバー表示 */
            scroll-behavior: smooth;
            min-height: 0; /* OK: Flexアイテムの縮小問題を回避 */
            /* スクロールバーのデザイン（任意） */
            scrollbar-width: thin;
            scrollbar-color: var(--bg-dark) var(--bg-mid);
        }
        #log-area::-webkit-scrollbar { width: 6px; }
        #log-area::-webkit-scrollbar-track { background: var(--bg-mid); border-radius: 3px; }
        #log-area::-webkit-scrollbar-thumb { background-color: var(--bg-dark); border-radius: 3px; border: 1px solid var(--bg-mid); }

        #log { font-size: 0.85em; } /* 変更なし */

        #battle-action-buttons {
            margin-top: 0; /* gapがあるので不要 */
            flex-shrink: 0; /* 高さは固定 */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 40px; /* 高さを確保 */
        }
        #battle-action-buttons button {
             width: auto;
             padding: 8px 20px;
             background-color: var(--accent-green);
        }
         #battle-action-buttons button:hover:not(:disabled) {
             background-color: #27ae60;
         }

        /* --- Wave間報酬選択画面 (変更なし) --- */
        #reward-modal { display: none; position: fixed; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(16, 21, 26, 0.9); z-index: 1000; justify-content: center; align-items: center; padding: 20px; box-sizing: border-box;} #reward-modal.active { display: flex; } #reward-content { background-color: var(--bg-mid); padding: 25px; border-radius: 10px; width: 95%; max-width: 850px; text-align: center; border: 2px solid var(--accent-yellow); max-height: 90vh; display: flex; flex-direction: column; box-shadow: 0 5px 15px rgba(0,0,0,0.3);} #reward-content h2 { color: var(--accent-yellow); margin-bottom: 15px; flex-shrink: 0; } #next-floor-details { display: flex; gap: 15px; margin-bottom: 15px; border-top: 1px dashed var(--bg-light); border-bottom: 1px dashed var(--bg-light); padding: 10px 0; flex-shrink: 0; max-height: 150px; overflow-y: auto;} #next-floor-info { flex: 1; text-align: left; } #next-floor-info h4 { margin-bottom: 5px; color: var(--text-light); text-align: center; } #next-floor-info p { font-size: 0.95em; color: var(--text-mid); margin: 0 0 10px 0; text-align: center;} #next-enemy-details-list { display: flex; gap: 10px; overflow-x: auto; padding-bottom: 5px;} .next-enemy-card { background-color: var(--bg-light); padding: 8px; border-radius: 5px; border: 1px solid var(--border-color); min-width: 160px; font-size: 0.8em;} .next-enemy-card h5 { margin: 0 0 5px 0; color: var(--accent-red); font-size: 1.1em; text-align: center;} .next-enemy-card p { margin: 2px 0; font-size: 0.95em;} .next-enemy-card .traits, .next-enemy-card .skills { font-size: 0.9em; } .next-enemy-card .skills ul { padding-left: 10px; list-style: disc; margin: 0; } .next-enemy-card .skills li { margin-bottom: 0; } #reward-options { display: flex; justify-content: center; gap: 15px; margin-bottom: 20px; flex-wrap: wrap; overflow-y: auto; padding: 10px; flex-grow: 1; align-content: flex-start; } .reward-card { background-color: var(--bg-light); padding: 15px; border-radius: 8px; border: 2px solid var(--border-color); flex-basis: 190px; flex-grow: 1; cursor: pointer; transition: all 0.2s ease; text-align: left; position: relative; overflow: hidden;} .reward-card::before { content: ''; position: absolute; top: 0; left: -100%; width: 50%; height: 100%; background: linear-gradient(to right, rgba(255,255,255,0) 0%, rgba(255,255,255,0.15) 50%, rgba(255,255,255,0) 100%); transform: skewX(-25deg); transition: left 0.4s ease; } .reward-card:hover::before { left: 150%; } .reward-card:hover { background-color: #5c7b97; transform: translateY(-3px); border-color: var(--accent-blue); box-shadow: 0 4px 8px rgba(0,0,0,0.2); } .reward-card.selected { border-color: var(--accent-green) !important; background-color: #507f6f !important; transform: scale(1.03) !important; box-shadow: 0 2px 5px rgba(0,0,0,0.15); } .reward-card h4 { margin: 0 0 8px 0; color: var(--accent-green); font-size: 1em; display: flex; align-items: center; gap: 5px; } .reward-card p { font-size: 0.85em; color: var(--text-mid); margin: 0 0 5px 0; line-height: 1.4;} .reward-card .reward-details { font-size: 0.8em; color: var(--text-light); border-top: 1px dashed var(--bg-dark); padding-top: 5px; margin-top: 8px; } .reward-card .magic-stone-value { color: var(--stone-color); font-weight: bold; }
        #reward-buttons { display: flex; justify-content: center; gap: 15px; margin-top: 15px; flex-shrink: 0; flex-wrap: wrap; }
        #confirm-reward-button { background-color: var(--accent-green); color: white; min-width: 140px;} #confirm-reward-button:hover:not(:disabled) { background-color: #27ae60; }
        #retire-button { background-color: var(--accent-orange); color: white; min-width: 140px;} #retire-button:hover { background-color: #d35400; }
        #close-reward-button { background-color: var(--accent-blue); color: white; min-width: 100px;}
        #close-reward-button:hover { background-color: #2980b9; }

         /* --- リザルト画面 (変更なし) --- */
         #result-screen { padding-top: 5vh; text-align: center; justify-content: center; align-items: center; flex-direction: column; }
         #result-screen .container { max-width: 600px; width: 90%; margin: 0 auto; display: flex; flex-direction: column; gap: 15px; background-color: var(--bg-mid); padding: 20px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.2); border: 1px solid var(--border-color); }
         #result-title { font-size: 2em; margin-bottom: 20px; }
         #result-title.win { color: var(--accent-green); } #result-title.lose { color: var(--accent-red); }
         .result-section { margin-bottom: 0; padding: 15px; background-color: var(--bg-light); border-radius: 6px;} .result-section h4 { color: var(--text-light); margin-bottom: 10px; border-bottom: 1px solid var(--bg-dark); padding-bottom: 5px; font-size: 1.1em; text-align: left;}
         #result-floor, #result-exp, #result-stones, #result-level, #result-next-exp { font-size: 1.1em; margin-bottom: 10px; color: var(--text-light); text-align: left;}
         #result-exp span, #result-level span, #result-next-exp span { color: var(--accent-yellow); font-weight: bold; }
         #result-stones span { color: var(--stone-color); font-weight: bold; }
         #inherited-info { font-size: 0.9em; color: var(--text-mid); line-height: 1.5; text-align: left; } #inherited-info ul { list-style: disc; padding-left: 20px; margin-top: 5px; } #inherited-info strong { color: var(--accent-yellow); }
         #result-buttons { display: flex; justify-content: center; gap: 20px; margin-top: 15px; } #retry-button { background-color: var(--accent-green); } #retry-button:hover { background-color: #27ae60; } #back-to-title-button { background-color: var(--accent-blue); } #back-to-title-button:hover { background-color: #2980b9; }

        /* Shared detail panel style (変更なし -> 一部変更あり) */
        .detail-panel-container { padding: 10px; background-color: var(--bg-mid); border-radius: 6px; border: 1px solid var(--border-color); flex-grow: 1; /* 高さを伸ばす */ overflow: hidden; /* スクロールは内部で行う */ display: flex; flex-direction: column; min-height: 200px; /* 最小高さを維持 */ }
        .detail-panel-container h4 { margin: 0 0 10px 0; color: var(--accent-yellow); font-size: 1.05em; flex-shrink: 0; /* タイトルは縮まない */ text-align: left; /* 左揃えにする */ padding-bottom: 5px; border-bottom: 1px solid var(--bg-light); }
        .detail-panel-content { font-size: 0.85em; flex-grow: 1; /* 残りのスペースを埋める */ overflow-y: auto; /* 内容がはみ出たらスクロール */ min-height: 0; /* flex縮小回避 */ /* スクロールバーのデザイン（任意） */ scrollbar-width: thin; scrollbar-color: var(--bg-dark) var(--bg-mid); }
        .detail-panel-content::-webkit-scrollbar { width: 6px; }
        .detail-panel-content::-webkit-scrollbar-track { background: var(--bg-mid); border-radius: 3px; }
        .detail-panel-content::-webkit-scrollbar-thumb { background-color: var(--bg-dark); border-radius: 3px; border: 1px solid var(--bg-mid); }
        .detail-panel-content .detail-section { margin-bottom: 10px; /* 少し間隔をあける */ }
        .detail-panel-content .detail-section h5 { font-size: 0.95em; margin-bottom: 4px; padding-bottom: 2px; color: var(--text-mid); text-align: left; }
        .detail-panel-content .detail-section p, .detail-panel-content .detail-section ul { margin: 3px 0; line-height: 1.5; /* 少し行間をあける */ }
        .detail-panel-content .stat-boost { color: var(--accent-green); font-weight: bold; margin-left: 3px; }
        .detail-panel-content .description { font-style: italic; color: var(--text-mid); margin-bottom: 8px; border-bottom: 1px dashed var(--bg-light); padding-bottom: 8px; font-size: 0.9em; line-height: 1.4;}
        .detail-panel-skills h5 { margin-bottom: 5px; } .detail-panel-skills ul { padding-left: 0; list-style: none; }
        .detail-panel-skills li { margin-bottom: 6px; /* 少し間隔をあける */ padding: 6px 8px; /* 少しパディング調整 */ border-radius: 4px; background-color: var(--bg-light); border: 1px solid var(--border-color); }
        .detail-panel-skills .skill-name { font-weight: bold; display: block; margin-bottom: 3px; /* 少し間隔調整 */ } .detail-panel-skills .skill-name.next-skill { color: var(--accent-yellow); }
        .detail-panel-skills .skill-info { font-size: 0.9em; color: var(--text-mid); line-height: 1.3; } .detail-panel-skills .skill-info span { margin-right: 8px; /* 少し間隔調整 */ display: inline-block; /* 折り返しのため */ margin-bottom: 2px; }
        .detail-panel-skills .skill-tags { font-size: 0.8em; background-color: var(--accent-purple); color: white; padding: 1px 4px; /* 少しパディング調整 */ border-radius: 3px; margin-left: 4px; /* 少し間隔調整 */ white-space: nowrap; }
        .detail-panel-placeholder { color: var(--text-dark); font-style: italic; text-align: center; padding: 20px; margin: auto; }
         .detail-panel-content .trait-list li { margin-bottom: 5px; }
         .detail-panel-content .trait-list .trait-name { font-weight: bold; display: inline-block; margin-right: 5px;}
         .detail-panel-content .trait-list .trait-desc { font-size: 0.95em; color: var(--text-mid); }
         /* Battle specific detail panel */
        #selected-char-details-battle { /* Inherits from .detail-panel-container */ }

        /* --- ツールチップ (変更なし) --- */
        #character-tooltip { display: none; position: absolute; background-color: rgba(0, 0, 0, 0.9); color: white; padding: 8px 10px; border-radius: 5px; font-size: 0.8em; max-width: 280px; z-index: 1000; border: 1px solid var(--text-dark); pointer-events: none; white-space: normal; line-height: 1.4; box-shadow: 0 2px 5px rgba(0,0,0,0.3); } #character-tooltip b { color: var(--accent-yellow); display: block; margin-bottom: 3px; } #character-tooltip span[title] { cursor: default; } #character-tooltip .status-icon { margin: 0 1px; }

        /* --- レスポンシブ対応 (変更) --- */
        @media (max-width: 1200px) {
            body { font-size: 14px; }
            #game-wrapper {
                grid-template-columns: repeat(2, 1fr); /* 2カラムに戻す */
                padding: 10px; /* パディングを戻す */
                gap: 10px; /* ギャップを戻す */
            }
            /* 各画面の2カラムレイアウト指定 (変更なし) */
            #hub-screen-col1 { display: none !important; }
            #hub-screen-col2 { grid-column: 1; grid-row: 1; }
            #hub-screen-col3 { grid-column: 2; grid-row: 1; }
            #hub-screen-col4 { grid-column: 1 / span 2; grid-row: 2; }
            #summon-contract-screen-col1 { grid-column: 1; grid-row: 1; } /* Col1/2結合なので Col1 のみ指定 */
            #summon-contract-screen-col3 { grid-column: 2; grid-row: 1; }
            #summon-contract-screen-col4 { grid-column: 1 / span 2; grid-row: 2; }
            #party-編成-screen-col1 { grid-column: 1; grid-row: 1; }
            #party-編成-screen-col2 { grid-column: 2; grid-row: 1; }
            #party-編成-screen-col3 { grid-column: 1; grid-row: 2; }
            #party-編成-screen-col4 { grid-column: 2; grid-row: 2; }
            #battle-screen-col1 { grid-column: 1; grid-row: 1; }
            #battle-screen-col2 { grid-column: 1; grid-row: 2; } /* プレイヤー */
            #battle-screen-col3 { grid-column: 2; grid-row: 2; } /* 敵 */
            #battle-screen-col4 { grid-column: 2; grid-row: 1; } /* ログなど */
            /* -- ここまで変更なし -- */

            /* 戦闘画面のカラム幅指定をリセット */
            #battle-screen.active {
                grid-template-columns: none; /* Gridの指定を解除 (親の指定に従う) */
            }
             /* カラム内のgapを戻す */
            .column { gap: 10px; }

            .character-card { width: calc(50% - 6px); min-width: 100px; }
            h1 { font-size: 1.6em; } h2 { font-size: 1.3em; }
            #column4-flavor-area { display: none !important; } /* 2カラム以下ではフレーバー非表示 */
        }

        @media (max-width: 768px) {
            #game-wrapper {
                grid-template-columns: 1fr; /* 1カラム */
                padding: 5px; gap: 5px;
            }
            /* 1カラム時のGrid解除 (既存の指定でOK) */
            .screen-content,
            #hub-screen-col1, #hub-screen-col2, #hub-screen-col3, #hub-screen-col4,
            #summon-contract-screen-col1, #summon-contract-screen-col3, #summon-contract-screen-col4,
            #party-編成-screen-col1, #party-編成-screen-col2, #party-編成-screen-col3, #party-編成-screen-col4,
            #battle-screen-col1, #battle-screen-col2, #battle-screen-col3, #battle-screen-col4 {
                grid-column: 1; grid-row: auto;
            }
            /* 1カラム時は flex column で表示 */
            #hub-screen.active, #summon-contract-screen.active, #party-編成-screen.active, #battle-screen.active {
                display: flex; flex-direction: column;
            }
            #hub-screen.active > .column, #summon-contract-screen.active > .column, #party-編成-screen.active > .column, #battle-screen.active > .column {
                width: 100%;
                margin-bottom: 10px; /* 各セクション間にマージン */
                gap: 10px; /* セクション内の要素間ギャップ */
            }
            #hub-screen.active > .column:last-child,
            #summon-contract-screen.active > .column:last-child,
            #party-編成-screen.active > .column:last-child,
            #battle-screen.active > .column:last-child {
                margin-bottom: 0;
            }

            /* 各要素の最大高さ、最小高さを調整 */
            #monster-pool-list-container, #current-party-list-container, .detail-panel-container, #log-area-container, #summon-list-container {
                max-height: 300px; /* 少し高さを許容 */
                min-height: 120px;
                flex-grow: 0; /* 1カラム時は高さ自動 */
                flex-shrink: 1; /* 必要なら縮む */
            }
            #party-info { max-height: 150px; flex-grow: 0; flex-shrink: 1; }
            .party-area { min-height: 120px; max-height: 250px; flex-grow: 0; flex-shrink: 1; }
            #battle-area-player, #battle-area-opponent { height: auto; } /* 高さを自動に */

            /* カードサイズ調整 */
            .character-card { width: calc(33.33% - 6px); min-width: 90px; }
            .party-area.many-units .character-card { width: calc(33.33% - 6px); }
            .party-area.very-many-units .character-card { width: calc(25% - 6px); }

            /* 報酬モーダル */
            #reward-modal #next-floor-details { flex-direction: column; max-height: 200px; }
            #reward-options { justify-content: space-around; } .reward-card { flex-basis: calc(50% - 10px); font-size: 0.95em;}

            /* その他 */
            #hub-buttons button { width: 90%; font-size: 1.1em; }
            .summon-list-item { flex-direction: column; align-items: flex-start; gap: 5px; } .summon-list-item .summon-cost { margin-left: auto; }
            #game-header { flex-direction: column; align-items: stretch; } #game-info-header { justify-content: center; }
            #column4-flavor-area { display: none !important; } /* 1カラムでも非表示 */
        }

        @media (max-width: 480px) {
            body { font-size: 13px; }
            .container { padding: 10px; }
            .character-card { width: calc(50% - 6px); min-width: 100px; }
            .party-area.many-units .character-card { width: calc(50% - 6px); }
            .party-area.very-many-units .character-card { width: calc(33.33% - 6px); }
            .reward-card { flex-basis: calc(100% - 10px); }
            #game-info-header span { font-size: 0.85em; margin: 2px 3px; }
            button { padding: 8px 14px; font-size: 0.9em; }
            #hub-buttons button { font-size: 1em; padding: 12px 0;}
        }
    </style>
</head>
<body>
    <div id="game-header">
        <div id="game-info-header">
             <span title="現在挑戦中の階層">階層: <strong id="wave-count">0</strong></span>
             <span title="召喚士のレベル">召喚士Lv: <strong id="account-level-value">0</strong></span>
             <span title="現在のパーティの平均レベル">パーティLv: <strong id="player-level-info">0</strong></span>
             <span id="exp-tooltip-wrapper" title="次の召喚士Lvまで: 0 / 0 魂片"> 次のLvまで: <strong id="exp-to-next-value">-</strong> 魂片 </span>
             <span id="magic-stone-info" title="モンスターとの契約に使用する魔石">魔石: <strong id="magic-stone-value">0</strong> <span title="魔石">💎</span></span>
        </div>
    </div>

    <div id="game-wrapper">
        <!-- Title Screen -->
        <div id="title-screen" class="screen-content container active">
            <h1>魔塔召喚戦記</h1>
            <p class="subtitle">～忘れられた塔の頂を目指して～</p>
            <p class="story">
                雲を貫きそびえ立つ、忘れられた「魔塔」。<br>
                その頂には、あらゆる願いを叶える力が眠ると言われる。<br>
                あなたは古代の術を受け継ぐ召喚士。<br>
                頼れる使い魔たちと共に、危険な魔物が待ち受ける塔の深奥へと挑む。
            </p>
            <p id="highest-floor-display" title="これまでの最高到達階層">最高到達階層: 0</p>
            <div id="title-buttons">
                <button id="start-game-button">冒険を始める</button>
                <button id="continue-game-button" class="hidden">続きから</button>
            </div>
        </div>

        <!-- Hub Screen (4 Column Layout) -->
        <div id="hub-screen" class="screen-content">
             <div id="hub-screen-col1" class="column"></div> <!-- Empty Col 1 for future use or spacing -->
             <div id="hub-screen-col2" class="column">
                 <div class="container">
                     <div id="hub-buttons">
                         <button id="hub-party-button">パーティ編成</button>
                         <button id="hub-summon-button">召喚契約</button>
                         <button id="hub-challenge-button">塔へ挑戦</button>
                     </div>
                 </div>
             </div>
             <div id="hub-screen-col3" class="column">
                 <div class="container">
                     <div id="hub-current-party-display">
                         <h4>現在のパーティ編成</h4>
                         <ul id="hub-party-list">
                             <!-- Party list items here -->
                         </ul>
                     </div>
                 </div>
             </div>
             <div id="hub-screen-col4" class="column">
                  <div id="column4-flavor-area">
                     <h5 id="column4-flavor-title">拠点の噂</h5>
                     <p id="column4-flavor-text">...</p>
                  </div>
                  <!-- Hub Detail Panel -->
                  <div id="hub-details-panel" class="detail-panel-container">
                      <h4 id="hub-selected-char-name">キャラクター詳細</h4>
                      <div class="detail-panel-content" id="hub-selected-char-content">
                          <p class="detail-panel-placeholder" id="hub-selected-char-placeholder">詳細を確認したいパーティメンバーをクリック</p>
                      </div>
                  </div>
             </div>
        </div>

        <!-- Summon Contract Screen (4 Column Layout) -->
        <div id="summon-contract-screen" class="screen-content">
             <div id="summon-contract-screen-col1" class="column">
                 <div class="container">
                     <h3 class="編成-column-title">契約候補</h3>
                     <div id="summon-list-container">
                         <ul id="summon-list"></ul>
                         <p id="summon-list-placeholder" class="hidden">契約可能な候補がいません。</p>
                     </div>
                 </div>
             </div>
             <div id="summon-contract-screen-col3" class="column">
                  <!-- Summon Detail Panel -->
                  <div id="summon-details-panel" class="detail-panel-container">
                      <h4 id="summon-selected-char-name">キャラクター詳細</h4>
                      <div class="detail-panel-content" id="summon-selected-char-content">
                          <p class="detail-panel-placeholder" id="summon-selected-char-placeholder">詳細を確認したい契約候補をクリック</p>
                      </div>
                  </div>
             </div>
             <div id="summon-contract-screen-col4" class="column">
                 <div id="column4-flavor-area">
                     <h5 id="column4-flavor-title">契約の知識</h5>
                     <p id="column4-flavor-text">...</p>
                 </div>
                 <div class="container">
                      <div id="summon-resource-info">所持魔石: <strong id="summon-stone-count">0</strong> <span title="魔石">💎</span></div>
                      <button id="back-to-hub-button">拠点へ戻る</button>
                  </div>
             </div>
        </div>

        <!-- Party Selection Screen -->
        <div id="party-編成-screen" class="screen-content">
            <div id="party-編成-screen-col1" class="column">
                <div class="container">
                    <h3 class="編成-column-title">召喚可能な使い魔</h3>
                    <div id="monster-pool-list-container">
                        <ul id="monster-pool-list"></ul>
                    </div>
                </div>
            </div>
            <div id="party-編成-screen-col2" class="column">
                <div class="container">
                    <h3 class="編成-column-title">現在のパーティ (<span id="current-party-count">0</span>/4)</h3>
                    <div id="current-party-list-container">
                        <ul id="current-party-list"></ul>
                    </div>
                </div>
            </div>
            <div id="party-編成-screen-col3" class="column">
                <!-- Party Detail Panel -->
                <div id="party-details-panel" class="detail-panel-container">
                    <h4 id="party-selected-char-name">キャラクター詳細</h4>
                    <div class="detail-panel-content" id="party-selected-char-content">
                        <p class="detail-panel-placeholder" id="party-selected-char-placeholder">詳細を確認したい使い魔をクリック</p>
                    </div>
                </div>
            </div>
            <div id="party-編成-screen-col4" class="column">
                 <div id="column4-flavor-area">
                    <h5 id="column4-flavor-title">編成の心得</h5>
                    <p id="column4-flavor-text">...</p>
                 </div>
                <div id="party-col4-buttons">
                    <button id="confirm-party-button">編成完了 (拠点へ)</button>
                 </div>
            </div>
        </div>

        <!-- Ready to Start Screen -->
        <div id="ready-to-start-screen" class="screen-content container">
             <h2>出撃準備完了！</h2>
             <div id="ready-party-summary"><h4>編成パーティ</h4><ul></ul></div>
             <div id="ready-screen-buttons">
                 <button id="start-first-wave-button">第1階層へ！</button>
                 <button id="back-to-hub-from-ready-button">拠点へ戻る</button>
             </div>
         </div>

        <!-- Setup Phase Screen -->
        <div id="setup-phase" class="screen-content container">
             <h2>第 <span id="setup-wave-number">1</span> 階層 準備</h2>
             <div id="enemy-preview"><h3>出現する魔物</h3><div id="enemy-list"></div></div>
             <button id="start-battle-button">戦闘開始！</button>
         </div>

        <!-- Battle Screen -->
        <div id="battle-screen" class="screen-content">
            <div id="battle-screen-col1" class="column">
                <div id="party-info" class="container">
                    <h3>パーティ</h3>
                    <div id="party-info-list"></div>
                </div>
                <!-- Battle Detail Panel -->
                <div id="selected-char-details-battle" class="detail-panel-container hidden">
                    <h4 id="selected-char-name-battle">キャラクター詳細</h4>
                    <div class="detail-panel-content" id="selected-char-content-battle">
                        <p class="detail-panel-placeholder" id="selected-char-placeholder-battle">キャラクターをクリックして詳細表示</p>
                    </div>
                </div>
            </div>
            <div id="battle-screen-col2" class="column">
                <div id="battle-area-player" class="container">
                    <h4>プレイヤー</h4>
                    <div id="player-party" class="party-area"></div>
                </div>
            </div>
            <div id="battle-screen-col3" class="column">
                <div id="battle-area-opponent" class="container">
                    <h4>敵</h4>
                    <div id="opponent-party" class="party-area"></div>
                </div>
            </div>
            <div id="battle-screen-col4" class="column">
                 <div id="column4-flavor-area">
                    <h5 id="column4-flavor-title">戦況</h5>
                    <p id="column4-flavor-text">...</p>
                 </div>
                 <div id="log-area-container" class="container">
                     <h3>戦闘記録</h3>
                     <div id="log-area">
                         <ul id="log"></ul>
                     </div>
                 </div>
                 <div id="battle-action-buttons">
                     <!-- Reward button added here by JS after win -->
                 </div>
            </div>
        </div>

        <!-- Result Screen -->
        <div id="result-screen" class="screen-content">
             <div class="container">
                 <h2 id="result-title">挑戦結果</h2>
                 <div class="result-section">
                     <h4>探索結果</h4>
                     <p id="result-floor">到達階層: 0</p>
                     <p id="result-exp">獲得した魂片 (EXP): <span>0</span></p>
                     <p id="result-stones">獲得した魔石: <span>0</span> <span title="魔石">💎</span></p>
                 </div>
                 <div class="result-section">
                     <h4>召喚士情報</h4>
                     <p id="result-level">召喚士レベル: <span>0</span></p>
                     <p id="result-next-exp" title="次のレベルまで">次のレベルまで: <span>0</span> 魂片</p>
                 </div>
                 <div class="result-section">
                     <h4>引き継ぎ情報</h4>
                     <p id="inherited-info">
                         今回の挑戦で得た魂片は召喚士レベルに、魔石は召喚契約に使用されます。<br>
                         以下の情報は次回の挑戦に引き継がれます:
                         <ul>
                             <li><strong>召喚士レベル</strong> とそれによるボーナス</li>
                             <li>これまでに<strong>契約した使い魔</strong></li>
                             <li>習得済みの<strong>パッシブスキル</strong></li>
                             <li>所持<strong>魔石</strong></li>
                             <li>契約可能な<strong>召喚候補</strong></li>
                         </ul>
                     </p>
                 </div>
                 <div id="result-buttons">
                     <button id="retry-button">拠点へ戻る</button>
                     <button id="back-to-title-button">タイトルへ戻る</button>
                 </div>
             </div>
         </div>

    </div> <!-- End of #game-wrapper -->

    <!-- Reward Modal -->
    <div id="reward-modal">
         <div id="reward-content">
             <h2>階層クリア！報酬を選択</h2>
             <div id="next-floor-details">
                 <div id="next-floor-info"><h4>次の階層の気配:</h4><p id="next-enemy-preview"></p></div>
                 <div id="next-enemy-details-list"> </div>
             </div>
             <div id="reward-options"></div>
             <div id="reward-buttons">
                 <button id="confirm-reward-button" disabled>報酬を確定して次へ</button>
                 <button id="retire-button">魔塔から帰還する</button>
                 <button id="close-reward-button">閉じる</button> <!-- Added Close Button -->
             </div>
         </div>
     </div>

    <!-- Tooltip Element -->
    <div id="character-tooltip" style="display: none;"></div>

    <script>
    // --- Constants (GAMEOVER rates updated) ---
    const PLAYER_PARTY_SIZE = 4; const MAX_SKILLS_PER_MONSTER = 4; const ACTION_DELAY = 70; const TURN_END_DELAY = 180; const DAMAGE_ANIMATION_DURATION = 150; const POPUP_DURATION = 800; const ACCOUNT_LEVEL_EXP_FACTOR = 25; const RETIRE_EXP_RATE = 0.6; const GAMEOVER_EXP_RATE = 0.5; /* Updated */ const RETIRE_STONE_RATE = 0.8; const GAMEOVER_STONE_RATE = 0.5; /* Updated */ const SUMMON_CANDIDATE_CHANCE = 0.05; const SAVE_DATA_KEY = 'mtSummonerSave_v3.9.9'; // バージョン更新
    const ACCOUNT_LEVEL_KEY = 'mtSummonerLevel_v3.9.9'; const HIGHEST_FLOOR_KEY = 'mtHighestFloor_v3.9.9'; const ACCOUNT_EXP_KEY = 'mtAccountExp_v3.9.9'; const MAGIC_STONE_KEY = 'mtMagicStones_v3.9.9'; const UNLOCKED_MONSTERS_KEY = 'mtUnlockedMonsters_v3.9.9'; const SUMMON_CANDIDATES_KEY = 'mtSummonCandidates_v3.9.9'; const PASSIVE_SKILLS_KEY = 'mtPassiveSkills_v3.9.9'; const INITIAL_UNLOCKED = ['p_slime', 'p_goblin', 'p_fairy', 'p_spirit'];
    const Attribute = { PHYSICAL: '物理', FIRE: '炎', ICE: '氷', HEAL: '回復', SUPPORT: '補助', POISON: '毒', HOLY: '聖', DARK: '闇', DRAIN: '吸血' }; const StatusEffect = { POISON: '毒', DEF_DOWN: '防御↓', ATK_UP: '攻撃↑', SLEEP: '睡眠', PARALYSIS: '麻痺', BURN: '燃焼', CURSE: '呪い', DEF_UP: '防御↑', PROTECTED: '護衛中', TEMP_ATK_UP: '一時攻撃↑', TEMP_FIRE_UP: '一時炎↑' }; const Trait = { FLYING: '飛行', UNDEAD: '不死', ARMOR: '装甲', MAGIC_RESIST: '魔法耐性', FIRE_WEAK: '炎弱点', ICE_IMMUNE: '氷無効', REGENERATE: '再生', COUNTER: '反撃' }; const GamePhase = { TITLE: 'title', HUB: 'hub', SUMMON_CONTRACT: 'summon', PARTY_SELECT: 'party', READY_TO_START: 'ready', SETUP: 'setup', BATTLE: 'battle', REWARD_SELECT: 'reward', RESULT: 'result' }; const AIType = { NORMAL: '通常', LOW_HP_FOCUS: '低HP狙い', HIGH_ATK_FOCUS: '高火力狙い', HEALER_HUNTER: '回復役狙い' }; const LogIcons = { player: '👤', opponent: '👹', system: '⚙️', damage: '💥', heal: '➕', miss: '💨', status: '✨', buff: '💪', debuff: '📉', info: 'ℹ️', turn: '⏳', win: '🏆', lose: '💀', poison: '☠️', burn: '🔥', curse: '👻', sleep: '😴', paralysis: '⚡', atk_up: '⚔️↑', def_down: '🛡️↓', def_up: '🛡️↑', protected: '🛡️✋', flying_evade: '🍃', undead_resist: '👻', armor_resist: '🛡️', magic_resist: '🔮', weakness: '🔥', resistance: '🛡️', immune: '🚫', reward: '🎁', retire: '🏳️', levelup: '🌟', critical: '❗', drain: '🩸', regenerate: '💖', counter: '🔄', unlock: '🔑', passive: '📜', flavor: '📜', tutorial: '💡', stone: '💎' };

    // === フレーバーテキスト (変更なし) ===
    const FlavorTexts = {
        [GamePhase.HUB]: [ "拠点だ。ここで次の挑戦への準備を整えよう。", "パーティは万全か？編成を見直すのも良いだろう。", "魔石があれば、新たな使い魔との契約も可能だ。「召喚契約」を覗いてみよう。", "塔の頂はまだ遠い…だが、諦めるわけにはいかない。", "「最も大きな危険は、危険を冒さないことだ。」…どこかで聞いた言葉だな。", "準備が整ったら、「塔へ挑戦」だ！健闘を祈る。", "使い魔との絆を深めることも、強さへの道だ。", "「千里の道も一歩から。」塔の攻略も同じことだ。", ],
        [GamePhase.SUMMON_CONTRACT]: [ "ここでは魔石💎を使い、新たな使い魔と契約できる。", "倒した魔物の中から、稀に契約可能な候補が見つかることがあるようだ。", "候補リストを確認し、戦略に合う使い魔を探そう。", "魔石は貴重だ。慎重に契約相手を選ぶと良いだろう。", "「未知なるものへの探求こそ、進歩の源泉だ。」", "より多くの使い魔がいれば、戦術の幅も広がるはずだ。", "契約は一方的なものではない。使い魔もまた、君を選んでいるのだ。", "【ヒント】候補に挙がった使い魔はここで契約しないと消えてしまうぞ！", ],
        [GamePhase.PARTY_SELECT]: [ "パーティ編成画面だ。最大4体の使い魔を選び出撃させよう。", "左のリストから召喚可能な使い魔を選び、「追加」ボタンでパーティへ。", "右のリストで現在のパーティを確認できる。「外す」で入れ替えも可能だ。", "キャラクターをクリックすると詳細情報が見れる。スキルや特性を確認しよう。", "バランスの取れたパーティか、一点特化か…「戦略とは選択である。」", "準備ができたら「編成完了」を押して拠点へ戻ろう。", "【ヒント】パーティ全体の平均レベルも戦闘の難易度に影響するぞ。", "【ヒント】敵の構成を見てからパーティを調整するのも有効だ。", "「備えあれば憂いなし。」パーティ編成は慎重にな。", ],
        [GamePhase.BATTLE]: [ "戦闘開始！使い魔たちの力を解き放て！", "敵の行動順は速度で決まる。「先んずれば人を制す」…必ずしもそうとは限らないが。", "キャラクターをクリックすれば、戦闘中でも詳細を確認できる。", "HPバーの色に注目。緑は安全、黄色は注意、赤は危険だ！", "状態異常アイコンにカーソルを合わせると効果時間などがわかるぞ。", "戦闘記録はこの画面右側で確認できる。", "「困難の中に、機会は横たわっている。」…アルベルト・アインシュタインだったか？", "最後まで諦めるな！逆転の鍵はどこかにあるはずだ。", "【ヒント】敵の特性（飛行、不死など）を考慮してスキルを選ぼう。", "【ヒント】防御スキルや回復スキルを使うタイミングも重要だ。", ],
        [GamePhase.READY_TO_START]: [ "出撃準備完了！編成したパーティで塔へ挑む。", "使い魔たちの顔ぶれを最終確認しよう。", "深呼吸をして、最初の階層へ…", "「旅の始まりは、いつも心躍るものだ。」", "準備は良いか？「拠点へ戻る」なら今のうちだ。", "彼らと共に、どこまで登れるだろうか…", ],
        [GamePhase.SETUP]: [ "次の階層の準備だ。出現する魔物を確認しよう。", "敵の構成を見て、戦略を練る。", "弱点を突ける使い魔はいるか？耐性を持つ敵は？", "「敵を知り、己を知れば、百戦危うからず。」孫子の言葉だ。", "準備ができたら「戦闘開始！」", "この階層にはどんな罠が待ち受けているのだろうか…", ],
        [GamePhase.REWARD_SELECT]: [ "階層クリア！報酬を選び、さらなる力を得よう。", "アビリティの習得、強化、ステータスアップ…どれを選ぶ？", "一時的な強化やリソース獲得も時には有効だ。", "「賢者はチャンスを見つけ、愚者はチャンスを待つ。」", "次の階層の敵情報も参考に、最適な報酬を選ぼう。", "ここで「魔塔から帰還する」ことも可能だ。無理は禁物だ。", "この選択が、未来を左右するかもしれない…", ],
         [GamePhase.RESULT]: [ "挑戦は終わった。結果を確認しよう。", "今回の探索で得た経験と資源は、次への糧となる。", "「失敗は成功のもと」と言う。今回の敗北から何を学ぶかだ。", "「勝利は最終的なものではなく、失敗は致命的なものではない。重要なのは続ける勇気だ。」…チャーチルだったか。", "拠点へ戻り、再び塔へ挑む準備をしよう。", "魂片はレベルに、魔石は新たな力に変わる。", ],
        default: [ "塔の中は常に変化している…", "召喚士よ、道を選び、進むのだ。", "集中を切らすな。一瞬の油断が命取りになる。", "古の囁きが聞こえる…", "星が…何かを語りかけているようだ…", ]
    };

    // --- Game State (isBattleEnded flag added) ---
    let gameState = {
        playerMonsterPool: [], playerPartyData: [], playerParty: [], opponentParty: [],
        battleManager: null, currentWave: 1, isGameOver: false,
        playerAccountLevel: 0, playerAccountTotalExp: 0, magicStones: 0,
        playerPartyLevel: 1, playerTotalExpInRun: 0, playerTotalStonesInRun: 0,
        difficulty: 'Normal', currentPhase: GamePhase.TITLE, selectedReward: null,
        highestFloor: 0, temporaryBuffs: {}, unlockedMonsters: [...INITIAL_UNLOCKED],
        summonCandidates: [],
        passiveSkills: {}, selectedCharacterId: null,
        isBattleEnded: false, // Flag to control log scrolling
    };

    // --- DOM Elements Cache (詳細パネルID変更) ---
    const DOMElements = {
        gameWrapper: document.getElementById('game-wrapper'),
        screens: { // Screens managed by switchScreen logic
            title: document.getElementById('title-screen'),
            hub: document.getElementById('hub-screen'),
            summon: document.getElementById('summon-contract-screen'),
            party: document.getElementById('party-編成-screen'),
            ready: document.getElementById('ready-to-start-screen'),
            setup: document.getElementById('setup-phase'),
            battle: document.getElementById('battle-screen'),
        },
        resultScreen: document.getElementById('result-screen'), // Result screen handled separately
        // Hub Screen Columns & Elements
        hubScreenCol1: document.getElementById('hub-screen-col1'),
        hubScreenCol2: document.getElementById('hub-screen-col2'),
        hubScreenCol3: document.getElementById('hub-screen-col3'),
        hubScreenCol4: document.getElementById('hub-screen-col4'),
        hubPartyButton: document.getElementById('hub-party-button'), hubSummonButton: document.getElementById('hub-summon-button'), hubChallengeButton: document.getElementById('hub-challenge-button'), hubCurrentPartyDisplay: document.getElementById('hub-current-party-display'), hubPartyList: document.getElementById('hub-party-list'),
        hubDetailsPanel: { // Hub Detail Panel Elements
            container: document.getElementById('hub-details-panel'),
            name: document.getElementById('hub-selected-char-name'),
            content: document.getElementById('hub-selected-char-content'),
            placeholder: document.getElementById('hub-selected-char-placeholder'),
        },
        // Summon Screen Columns & Elements
        summonContractScreenCol1: document.getElementById('summon-contract-screen-col1'),
        summonContractScreenCol3: document.getElementById('summon-contract-screen-col3'),
        summonContractScreenCol4: document.getElementById('summon-contract-screen-col4'),
        summonStoneCount: document.getElementById('summon-stone-count'), summonListContainer: document.getElementById('summon-list-container'), summonList: document.getElementById('summon-list'), summonListPlaceholder: document.getElementById('summon-list-placeholder'), backToHubButton: document.getElementById('back-to-hub-button'), summonResourceInfo: document.getElementById('summon-resource-info'),
        summonDetailsPanel: { // Summon Detail Panel Elements
            container: document.getElementById('summon-details-panel'),
            name: document.getElementById('summon-selected-char-name'),
            content: document.getElementById('summon-selected-char-content'),
            placeholder: document.getElementById('summon-selected-char-placeholder'),
        },
        // Party Screen Columns & Elements
        partyScreenCol1: document.getElementById('party-編成-screen-col1'), partyScreenCol2: document.getElementById('party-編成-screen-col2'),
        partyScreenCol3: document.getElementById('party-編成-screen-col3'),
        partyScreenCol4: document.getElementById('party-編成-screen-col4'), monsterPoolList: document.getElementById('monster-pool-list'), monsterPoolListContainer: document.getElementById('monster-pool-list-container'), currentPartyList: document.getElementById('current-party-list'), currentPartyListContainer: document.getElementById('current-party-list-container'), currentPartyCount: document.getElementById('current-party-count'), partyCol4Buttons: document.getElementById('party-col4-buttons'), confirmPartyButton: document.getElementById('confirm-party-button'),
        partyDetailsPanel: { // Party Detail Panel Elements
            container: document.getElementById('party-details-panel'),
            name: document.getElementById('party-selected-char-name'),
            content: document.getElementById('party-selected-char-content'),
            placeholder: document.getElementById('party-selected-char-placeholder'),
        },
        // Column 4 Flavor elements
        column4FlavorArea: document.getElementById('column4-flavor-area'),
        column4FlavorTitle: document.getElementById('column4-flavor-title'),
        column4FlavorText: document.getElementById('column4-flavor-text'),
        // Battle Screen Columns & Elements
        battleScreenCol1: document.getElementById('battle-screen-col1'),
        battleScreenCol2: document.getElementById('battle-screen-col2'), battleScreenCol3: document.getElementById('battle-screen-col3'), battleScreenCol4: document.getElementById('battle-screen-col4'), playerPartyArea: document.getElementById('player-party'), opponentPartyArea: document.getElementById('opponent-party'), battleAreaPlayerContainer: document.getElementById('battle-area-player'), battleAreaOpponentContainer: document.getElementById('battle-area-opponent'),
        partyInfo: document.getElementById('party-info'), partyInfoList: document.getElementById('party-info-list'),
        // Battle Specific Detail Panel Elements
        battleDetailsPanel: {
             container: document.getElementById('selected-char-details-battle'),
             name: document.getElementById('selected-char-name-battle'),
             content: document.getElementById('selected-char-content-battle'),
             placeholder: document.getElementById('selected-char-placeholder-battle'),
        },
        // Log elements
        logAreaContainer: document.getElementById('log-area-container'),
        logArea: document.getElementById('log-area'),
        logList: document.getElementById('log'),
        battleActionButtons: document.getElementById('battle-action-buttons'),
        // Result Screen Elements
        resultScreenContainer: document.querySelector('#result-screen .container'), resultTitle: document.getElementById('result-title'), resultFloor: document.getElementById('result-floor'), resultExp: document.getElementById('result-exp'), resultStones: document.getElementById('result-stones'), resultLevel: document.getElementById('result-level'), resultNextExp: document.getElementById('result-next-exp'), inheritedInfo: document.getElementById('inherited-info'), retryButton: document.getElementById('retry-button'), backToTitleButton: document.getElementById('back-to-title-button'),
        // Header Elements
        gameInfoHeader: document.getElementById('game-info-header'), waveCountInfo: document.getElementById('wave-count'), accountLevelInfo: document.getElementById('account-level-value'), playerLevelInfo: document.getElementById('player-level-info'), expToNextInfo: document.getElementById('exp-to-next-value'), expTooltipWrapper: document.getElementById('exp-tooltip-wrapper'), magicStoneInfo: document.getElementById('magic-stone-info'), magicStoneValue: document.getElementById('magic-stone-value'),
        // Ready Screen Elements
        readyPartySummary: document.getElementById('ready-party-summary'), readyScreenButtons: document.getElementById('ready-screen-buttons'), startFirstWaveButton: document.getElementById('start-first-wave-button'), backToHubFromReadyButton: document.getElementById('back-to-hub-from-ready-button'),
        // Setup Screen Elements
        setupWaveNumber: document.getElementById('setup-wave-number'), enemyListDiv: document.getElementById('enemy-list'), startBattleButton: document.getElementById('start-battle-button'),
        // Reward Modal Elements
        rewardModal: document.getElementById('reward-modal'), nextFloorInfoP: document.getElementById('next-enemy-preview'), nextEnemyDetailsList: document.getElementById('next-enemy-details-list'), rewardOptionsDiv: document.getElementById('reward-options'), confirmRewardButton: document.getElementById('confirm-reward-button'), retireButton: document.getElementById('retire-button'), closeRewardButton: document.getElementById('close-reward-button'),
        // Title Screen Elements
        startGameButton: document.getElementById('start-game-button'), continueGameButton: document.getElementById('continue-game-button'), highestFloorDisplay: document.getElementById('highest-floor-display'),
        tooltipElement: document.getElementById('character-tooltip'),
    };

    // --- Utility Functions (変更なし) ---
    const Utils = { delay: (ms) => new Promise(resolve => setTimeout(resolve, ms)), getRandomInt: (min, max) => Math.floor(Math.random() * (max - min + 1)) + min, shuffleArray: (array) => { for (let i = array.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [array[i], array[j]] = [array[j], array[i]]; } return array; }, getExpForNextAccountLevel: (currentLevel) => (currentLevel + 1) * ACCOUNT_LEVEL_EXP_FACTOR + Math.floor(Math.pow(currentLevel, 1.5)), saveGame: () => { try { const saveData = { currentWave: gameState.currentWave, playerTotalExpInRun: gameState.playerTotalExpInRun, playerTotalStonesInRun: gameState.playerTotalStonesInRun, playerPartyData: gameState.playerPartyData.map(p => ({ ...p, skills: p.skills.map(s => s.id || 'unknown') })), temporaryBuffs: gameState.temporaryBuffs, }; localStorage.setItem(SAVE_DATA_KEY, JSON.stringify(saveData)); console.log("Game Saved (Run Progress)."); } catch (e) { console.error("Failed to save game:", e); } }, loadGame: () => { const savedString = localStorage.getItem(SAVE_DATA_KEY); if (savedString) { try { const loadedData = JSON.parse(savedString); gameState.currentWave = loadedData.currentWave || 1; gameState.playerTotalExpInRun = loadedData.playerTotalExpInRun || 0; gameState.playerTotalStonesInRun = loadedData.playerTotalStonesInRun || 0; gameState.playerPartyData = (loadedData.playerPartyData || []).map(p => ({ ...p, skills: p.skills.map(id => SkillDatabase[id]).filter(Boolean) })); gameState.temporaryBuffs = loadedData.temporaryBuffs || {}; account.loadPermanentData(); console.log("Game Loaded (Run Progress)."); return true; } catch (e) { console.error("Failed to load save data:", e); Utils.deleteSaveData(); return false; } } return false; }, deleteSaveData: () => { localStorage.removeItem(SAVE_DATA_KEY); console.log("Save data (Run Progress) deleted."); }, formatNumber: (num) => num.toLocaleString() };

     // --- Account Management (変更なし) ---
     const account = {
         loadPermanentData: () => { gameState.playerAccountLevel = parseInt(localStorage.getItem(ACCOUNT_LEVEL_KEY) || '0'); gameState.highestFloor = parseInt(localStorage.getItem(HIGHEST_FLOOR_KEY) || '0'); gameState.playerAccountTotalExp = parseInt(localStorage.getItem(ACCOUNT_EXP_KEY) || '0'); gameState.magicStones = parseInt(localStorage.getItem(MAGIC_STONE_KEY) || '0'); gameState.unlockedMonsters = JSON.parse(localStorage.getItem(UNLOCKED_MONSTERS_KEY) || JSON.stringify(INITIAL_UNLOCKED)); gameState.summonCandidates = JSON.parse(localStorage.getItem(SUMMON_CANDIDATES_KEY) || '[]'); gameState.passiveSkills = JSON.parse(localStorage.getItem(PASSIVE_SKILLS_KEY) || '{}'); INITIAL_UNLOCKED.forEach(id => { if (!gameState.unlockedMonsters.includes(id)) gameState.unlockedMonsters.push(id); }); console.log("Permanent data loaded. Level:", gameState.playerAccountLevel, "Stones:", gameState.magicStones, "Candidates:", gameState.summonCandidates.length); },
         savePermanentData: () => { try { localStorage.setItem(ACCOUNT_LEVEL_KEY, gameState.playerAccountLevel.toString()); localStorage.setItem(HIGHEST_FLOOR_KEY, gameState.highestFloor.toString()); localStorage.setItem(ACCOUNT_EXP_KEY, gameState.playerAccountTotalExp.toString()); localStorage.setItem(MAGIC_STONE_KEY, gameState.magicStones.toString()); localStorage.setItem(UNLOCKED_MONSTERS_KEY, JSON.stringify(gameState.unlockedMonsters)); localStorage.setItem(SUMMON_CANDIDATES_KEY, JSON.stringify(gameState.summonCandidates)); localStorage.setItem(PASSIVE_SKILLS_KEY, JSON.stringify(gameState.passiveSkills)); console.log("Permanent data saved. Level:", gameState.playerAccountLevel, "Stones:", gameState.magicStones, "Candidates:", gameState.summonCandidates.length); } catch (e) { console.error("Failed to save permanent data:", e); } },
         addExperience: (expAmount) => { if (expAmount <= 0) return; gameState.playerAccountTotalExp += expAmount; console.log(`Gained ${expAmount} Account Exp. Total: ${gameState.playerAccountTotalExp}`); account.checkAndApplyAccountLevelUp(); account.savePermanentData(); UIController.updateGameInfo(); },
         addMagicStones: (amount) => { if (amount <= 0) return; gameState.magicStones += amount; console.log(`Gained ${amount} Magic Stones. Total: ${gameState.magicStones}`); account.savePermanentData(); UIController.updateGameInfo(); },
         spendMagicStones: (amount) => { if (amount <= 0 || gameState.magicStones < amount) { return false; } gameState.magicStones -= amount; console.log(`Spent ${amount} Magic Stones. Remaining: ${gameState.magicStones}`); account.savePermanentData(); UIController.updateGameInfo(); return true; },
         checkAndApplyAccountLevelUp: () => { let expForCurrentLevelTotal = 0; for(let i = 0; i < gameState.playerAccountLevel; i++) { expForCurrentLevelTotal += Utils.getExpForNextAccountLevel(i); } let expNeeded = Utils.getExpForNextAccountLevel(gameState.playerAccountLevel); let leveledUp = false; while (gameState.playerAccountTotalExp >= expForCurrentLevelTotal + expNeeded) { gameState.playerAccountLevel++; leveledUp = true; UIController.log(`召喚士レベルが ${gameState.playerAccountLevel} に上昇！`, 'log-win', {icon: LogIcons.levelup}); account.applyAccountLevelUpBonus(gameState.playerAccountLevel); expForCurrentLevelTotal += expNeeded; expNeeded = Utils.getExpForNextAccountLevel(gameState.playerAccountLevel); } if (leveledUp) { UIController.updateGameInfo(); } },
         applyAccountLevelUpBonus: (newLevel) => { if (newLevel % 5 === 0) { UIController.log(`ボーナス: 初期使い魔のレベルが上がりやすくなった！`, 'log-info', {icon: '✨'}); } const passiveMapping = { 3: 'waveHealBonus', 7: 'rewardChoiceBonus', 12: 'expGainBonus', 18: 'stoneGainBonus' }; if (passiveMapping[newLevel] && !gameState.passiveSkills[passiveMapping[newLevel]]) { gameState.passiveSkills[passiveMapping[newLevel]] = true; let skillDesc = ''; if (passiveMapping[newLevel] === 'waveHealBonus') skillDesc = '階層クリア時のHP回復量アップ'; else if (passiveMapping[newLevel] === 'rewardChoiceBonus') skillDesc = '報酬の選択肢が稀に増加'; else if (passiveMapping[newLevel] === 'expGainBonus') skillDesc = '魂片の獲得量が少し増加'; else if (passiveMapping[newLevel] === 'stoneGainBonus') skillDesc = '魔石の獲得量が少し増加'; UIController.log(`パッシブスキル習得: ${skillDesc}`, 'log-info', {icon: LogIcons.passive}); } account.savePermanentData(); },
         getAccountLevelBonus: (type) => { switch(type) { case 'initialMonsterLevel': return Math.floor(gameState.playerAccountLevel / 4); case 'waveHealMultiplier': return gameState.passiveSkills.waveHealBonus ? 1.3 : 1.0; case 'rewardOptions': return gameState.passiveSkills.rewardChoiceBonus && Math.random() < 0.15 ? 4 : 3; case 'expGainMultiplier': return gameState.passiveSkills.expGainBonus ? 1.1 : 1.0; case 'stoneGainMultiplier': return gameState.passiveSkills.stoneGainBonus ? 1.15 : 1.0; default: return 0; } }
     };

    // --- Descriptions and Icons (変更なし) ---
    const TraitDescriptions = { [Trait.FLYING]: "飛行: [対空]タグを持たない近接物理攻撃を高確率(70%)で回避する。", [Trait.UNDEAD]: "不死: 聖属性に弱く(x1.5)、闇属性に耐性(x0.5)を持つ。毒・睡眠・燃焼・呪いを無効化し、HP回復効果を受け付けない。", [Trait.ARMOR]: "装甲: 物理属性の被ダメージを軽減(x0.7)する。[装甲無視]タグを持つスキルはこの効果を受けない。", [Trait.MAGIC_RESIST]: "魔法耐性: 炎・氷・聖・闇属性の被ダメージを軽減(x0.7)する。", [Trait.FIRE_WEAK]: "炎弱点: 炎属性の被ダメージが増加(x1.5)する。", [Trait.ICE_IMMUNE]: "氷無効: 氷属性のダメージを完全に無効化する。", [Trait.REGENERATE]: "再生: ターン終了時に最大HPの5%を自動回復する。", [Trait.COUNTER]: "反撃: 物理攻撃を受けた際、確率(30%)で通常攻撃による反撃を行う。", };
    const TraitIcons = { [Trait.FLYING]: "🕊️", [Trait.UNDEAD]: "💀", [Trait.ARMOR]: "🛡️", [Trait.MAGIC_RESIST]: "🔮", [Trait.FIRE_WEAK]: "🔥", [Trait.ICE_IMMUNE]: "❄️", [Trait.REGENERATE]: "💖", [Trait.COUNTER]: "🔄", };
    const StatusDescriptions = { [StatusEffect.POISON]: "毒: ターン終了時に最大HPの割合(8%)ダメージを受ける。", [StatusEffect.BURN]: "燃焼: ターン終了時に最大HPの割合(6%)ダメージを受ける。不死は無効。", [StatusEffect.CURSE]: "呪い: ターン終了時に最大HPの割合(4%)ダメージを受け、HP回復効果が半減する。不死は無効。", [StatusEffect.DEF_DOWN]: "防御力低下: 防御力が低下(x0.7)している。", [StatusEffect.ATK_UP]: "攻撃力上昇: 攻撃力が上昇(x1.3)している。", [StatusEffect.DEF_UP]: "防御力上昇: 防御力が上昇(x1.3)している。", [StatusEffect.SLEEP]: "睡眠: 行動不能になる。ダメージを受けると確率(33%)で解除される。不死は無効。", [StatusEffect.PARALYSIS]: "麻痺: 確率(40%)で行動不能になる。", [StatusEffect.PROTECTED]: "護衛中: 次に受ける単体対象スキルを、スキル使用者が代わりに受ける。", [StatusEffect.TEMP_ATK_UP]: "一時攻撃上昇: この戦闘中、攻撃力が上昇している。", [StatusEffect.TEMP_FIRE_UP]: "一時炎攻撃上昇: この戦闘中、炎属性スキルの威力が上昇している。", };
    const StatusIcons = { [StatusEffect.POISON]: '☠️', [StatusEffect.BURN]: '🔥', [StatusEffect.CURSE]: '👻', [StatusEffect.DEF_DOWN]: '🛡️↓', [StatusEffect.ATK_UP]: '⚔️↑', [StatusEffect.DEF_UP]: '🛡️↑', [StatusEffect.SLEEP]: '😴', [StatusEffect.PARALYSIS]: '⚡', [StatusEffect.PROTECTED]: '🛡️✋', [StatusEffect.TEMP_ATK_UP]: '⚔️+', [StatusEffect.TEMP_FIRE_UP]: '🔥+', };

    // --- SkillDatabase and Descriptions (変更なし) ---
    const SkillDatabase = { slash: { id:'slash', name: "斬撃", type: Attribute.PHYSICAL, power: 25, target: 'enemy_single', attribute: Attribute.PHYSICAL }, bite: { id:'bite', name: "噛付", type: Attribute.PHYSICAL, power: 20, target: 'enemy_single', attribute: Attribute.PHYSICAL }, armor_break: { id:'armor_break', name: "鎧砕き", type: Attribute.PHYSICAL, power: 15, target: 'enemy_single', attribute: Attribute.PHYSICAL, effect: StatusEffect.DEF_DOWN, chance: 0.5, turns: 3 }, poison_stab: { id:'poison_stab', name: "毒突き", type: Attribute.PHYSICAL, power: 18, target: 'enemy_single', attribute: Attribute.PHYSICAL, effect: StatusEffect.POISON, chance: 0.4, turns: 3 }, pierce: { id:'pierce', name: "貫通突き", type: Attribute.PHYSICAL, power: 22, target: 'enemy_single', attribute: Attribute.PHYSICAL, tags: ['armor_piercing'] }, sky_strike: { id:'sky_strike', name: "対空撃", type: Attribute.PHYSICAL, power: 28, target: 'enemy_single', attribute: Attribute.PHYSICAL, tags: ['anti_air'] }, paralysis_claw: { id:'paralysis_claw', name: "麻痺爪", type: Attribute.PHYSICAL, power: 15, target: 'enemy_single', attribute: Attribute.PHYSICAL, effect: StatusEffect.PARALYSIS, chance: 0.3, turns: 2 }, rampage: { id:'rampage', name: "暴れまわる", type: Attribute.PHYSICAL, power: 40, target: 'enemy_all', attribute: Attribute.PHYSICAL }, fireball: { id:'fireball', name: "火球", type: Attribute.FIRE, power: 30, target: 'enemy_single', attribute: Attribute.FIRE }, fire_breath: { id:'fire_breath', name: "炎の息", type: Attribute.FIRE, power: 25, target: 'enemy_all', attribute: Attribute.FIRE, effect: StatusEffect.BURN, chance: 0.2, turns: 2 }, ice_shard: { id:'ice_shard', name: "氷片", type: Attribute.ICE, power: 28, target: 'enemy_single', attribute: Attribute.ICE }, blizzard: { id:'blizzard', name: "吹雪", type: Attribute.ICE, power: 22, target: 'enemy_all', attribute: Attribute.ICE }, holy_light: { id:'holy_light', name: "聖なる光", type: Attribute.HOLY, power: 32, target: 'enemy_single', attribute: Attribute.HOLY, tags: ['undead_slayer'] }, divine_ray: { id:'divine_ray', name: "神の光線", type: Attribute.HOLY, power: 28, target: 'enemy_all', attribute: Attribute.HOLY, tags: ['undead_slayer'] }, dark_bolt: { id:'dark_bolt', name: "闇の矢", type: Attribute.DARK, power: 30, target: 'enemy_single', attribute: Attribute.DARK }, curse: { id:'curse', name: "呪詛", type: Attribute.DARK, power: 0, target: 'enemy_single', attribute: Attribute.DARK, effect: StatusEffect.CURSE, chance: 0.7, turns: 3 }, drain_touch: { id:'drain_touch', name: "吸血の手", type: Attribute.DRAIN, power: 20, target: 'enemy_single', attribute: Attribute.DARK, drainRate: 0.5 }, sleep_cloud: { id:'sleep_cloud', name: "眠りの雲", type: Attribute.SUPPORT, power: 0, target: 'enemy_single', attribute: Attribute.DARK, effect: StatusEffect.SLEEP, chance: 0.6, turns: 2 }, heal_light: { id:'heal_light', name: "癒しの光", type: Attribute.HEAL, power: 50, target: 'ally_single' }, multi_heal: { id:'multi_heal', name: "広域回復", type: Attribute.HEAL, power: 30, target: 'ally_all' }, power_up: { id:'power_up', name: "力溜め", type: Attribute.SUPPORT, power: 0, target: 'self', effect: StatusEffect.ATK_UP, turns: 3 }, iron_wall: { id:'iron_wall', name: "鉄壁", type: Attribute.SUPPORT, power: 0, target: 'self', effect: StatusEffect.DEF_UP, turns: 3 }, protect: { id:'protect', name: "護衛指示", type: Attribute.SUPPORT, power: 0, target: 'ally_single', effect: StatusEffect.PROTECTED, turns: 1 }, detoxify: { id: 'detoxify', name: "解毒", type: Attribute.SUPPORT, power: 0, target: 'ally_single', effect: 'remove_poison' }, };
    const SkillDescriptions = { slash: "敵単体に物理ダメージを与える基本的な斬撃。", bite: "敵単体に物理ダメージを与える。", armor_break: "敵単体に物理ダメージを与え、確率で相手の防御力を低下させる。", poison_stab: "敵単体に物理ダメージを与え、確率で相手を毒状態にする。", pierce: "装甲特性を無視してダメージを与える物理攻撃。", sky_strike: "飛行特性を持つ相手に大ダメージを与える物理攻撃。", paralysis_claw: "敵単体に物理ダメージを与え、確率で相手を麻痺状態にする。", rampage: "敵全体に物理ダメージを与える。", fireball: "敵単体に炎属性の魔法ダメージを与える。", fire_breath: "敵全体に炎属性の魔法ダメージを与え、確率で燃焼状態にする。", ice_shard: "敵単体に氷属性の魔法ダメージを与える。", blizzard: "敵全体に氷属性の魔法ダメージを与える。", holy_light: "敵単体に聖属性の魔法ダメージを与える。不死特性を持つ相手に特に有効。", divine_ray: "敵全体に聖属性の魔法ダメージを与える。不死に有効。", dark_bolt: "敵単体に闇属性の魔法ダメージを与える。", curse: "相手を呪い状態にし、持続ダメージと回復量半減の効果を与える。", drain_touch: "敵単体に闇属性ダメージを与え、与えたダメージ量に応じて自身のHPを回復する。", sleep_cloud: "相手を確率で睡眠状態にする。", heal_light: "味方単体のHPを回復する。", multi_heal: "味方全体のHPを少量回復する。", power_up: "自身の攻撃力を一時的に上昇させる。", iron_wall: "自身の防御力を一時的に上昇させる。", protect: "指定した味方を護衛状態にし、次の単体攻撃を肩代わりさせる。", detoxify: "味方単体の毒状態を解除する。", };

    // --- Character Class (renderにクリックイベント削除) ---
    let uniqueIdCounter = 0; let partyMemberCounter = 0;
    class Character {
        constructor(baseData, team, level = 1, initialSkills = null, uniqueId = null, aiType = AIType.NORMAL, boostedStats = null) { this.uniqueId = uniqueId || (team === 'player' ? `p-uuid-${partyMemberCounter++}` : `e-${uniqueIdCounter++}`); this.baseId = baseData.id; this.name = baseData.name; this.description = baseData.description || "詳細不明の存在。"; this.team = team; this.level = level; this.traits = [...(baseData.traits || [])]; const levelMultiplier = 1 + (level - 1) * 0.08; this.maxHpBase = Math.round(baseData.hp * levelMultiplier * Utils.getRandomInt(95, 105) / 100); this.baseAtkBase = Math.round(baseData.atk * levelMultiplier); this.baseDefBase = Math.round(baseData.def * levelMultiplier); this.speed = Math.round(baseData.speed * (1 + (level-1)*0.04) * (1 + Math.random() * 0.1 - 0.05)); this.boostedStats = boostedStats ? { ...boostedStats } : { hp: 0, atk: 0, def: 0 }; this.maxHp = this.maxHpBase + this.boostedStats.hp; this.hp = this.maxHp; this.baseAtk = this.baseAtkBase + this.boostedStats.atk; this.baseDef = this.baseDefBase + this.boostedStats.def; if (initialSkills && initialSkills.length > 0) { if (typeof initialSkills[0] === 'string') { this.skills = initialSkills.map(id => SkillDatabase[id]).filter(Boolean); } else { this.skills = JSON.parse(JSON.stringify(initialSkills)); } } else { this.skills = JSON.parse(JSON.stringify(baseData.skills || [])); } this.resistances = { ...(baseData.resistances || {}) }; this.statusEffects = {}; this.nextSkillIndex = 0; this.element = null; this.aiType = aiType; this.recalculateStats(); }
        render() { const card = document.createElement('div'); card.id = this.uniqueId; card.classList.add('character-card'); card.dataset.characterId = this.uniqueId; card.dataset.uniqueId = this.uniqueId; /* datasetにも追加 */ card.innerHTML = `<div class="char-name">${this.name} <span class="level">(Lv${this.level})</span></div><div class="traits-icons"></div><div class="hp-bar-container"><div class="hp-bar"></div></div><div class="char-hp">HP: ${this.hp}/${this.maxHp}</div><div class="status-icons"></div>`; this.element = card; this.updateDisplay(); card.addEventListener('mouseenter', () => UIController.showTooltip(this)); card.addEventListener('mouseleave', () => UIController.hideTooltip()); return card; }
        updateDisplay() { if (!this.element || !this.element.isConnected) return; const hpBar = this.element.querySelector('.hp-bar'); const hpText = this.element.querySelector('.char-hp'); const traitsIconsDiv = this.element.querySelector('.traits-icons'); const statusIconsDiv = this.element.querySelector('.status-icons'); const levelText = this.element.querySelector('.level'); hpText.textContent = `HP: ${this.hp}/${this.maxHp}`; const hpPercent = Math.max(0, (this.hp / this.maxHp) * 100); hpBar.style.width = `${hpPercent}%`; hpBar.className = 'hp-bar'; if (hpPercent <= 25) hpBar.classList.add('low'); else if (hpPercent <= 60) hpBar.classList.add('mid'); else hpBar.classList.add('high'); const partyLi = DOMElements.partyInfoList?.querySelector(`li[data-character-id="${this.uniqueId}"]`); if(partyLi){ const partyHpBar = partyLi.querySelector(`.party-hp-bar`); const partyHpText = partyLi.querySelector(`.hp`); if(partyHpBar) { partyHpBar.style.width = `${hpPercent}%`; partyHpBar.className = 'party-hp-bar'; if (hpPercent <= 25) partyHpBar.classList.add('low'); else if (hpPercent <= 60) partyHpBar.classList.add('mid'); else partyHpBar.classList.add('high'); } if(partyHpText) partyHpText.textContent = `${this.hp}/${this.maxHp}`; partyLi.classList.toggle('dead', !this.isAlive()); } levelText.textContent = `(Lv${this.level})`; traitsIconsDiv.innerHTML = ''; this.traits.forEach(trait => { const icon = document.createElement('span'); icon.classList.add('trait-icon'); icon.textContent = TraitIcons[trait] || '?'; icon.title = TraitDescriptions[trait] || trait; traitsIconsDiv.appendChild(icon); }); statusIconsDiv.innerHTML = ''; for (const type in this.statusEffects) { const effect = this.statusEffects[type]; const icon = document.createElement('span'); icon.classList.add('status-icon'); let iconText = ''; if (effect.turns < 99) iconText += effect.turns; const iconClass = `icon-${type.toLowerCase().replace('↓','_down').replace('↑','_up').replace(' ','_')}`; icon.classList.add(...iconClass.split(' ')); icon.textContent = (StatusIcons[type] || type.substring(0,1)) + iconText; icon.title = `${type}: ${StatusDescriptions[type] || '効果不明'} (${effect.turns === Infinity ? '永続' : effect.turns + 'T 残り'})`; statusIconsDiv.appendChild(icon); } this.element.classList.toggle('dead', !this.isAlive()); this.element.classList.toggle('selected-in-detail', this.uniqueId === gameState.selectedCharacterId); }
        isAlive() { return this.hp > 0; }
        hasStatus(statusType) { return statusType in this.statusEffects; }
        addStatus(type, turns, sourceId = null) { if (!this.isAlive()) return false; if (this.traits.includes(Trait.UNDEAD) && [StatusEffect.POISON, StatusEffect.SLEEP, StatusEffect.BURN, StatusEffect.CURSE].includes(type)) { UIController.log(`${this.name} は ${type} を無効化 (不死)`, 'log-miss', { icon: LogIcons.undead_resist }); return false; } if (type === StatusEffect.SLEEP && this.hasStatus(StatusEffect.PARALYSIS)) this.removeStatus(StatusEffect.PARALYSIS); if (type === StatusEffect.PARALYSIS && this.hasStatus(StatusEffect.SLEEP)) this.removeStatus(StatusEffect.SLEEP); if (this.hasStatus(type) && this.statusEffects[type].turns !== Infinity && turns !== Infinity && this.statusEffects[type].turns >= turns) { return false; } this.statusEffects[type] = { turns: turns === Infinity ? Infinity : turns, sourceId: sourceId }; UIController.log(`${this.name} は ${type} 状態になった (${turns === Infinity ? '永続' : turns + 'T'})`, 'log-status', { icon: LogIcons[type.toLowerCase().replace('↓','_down').replace('↑','_up')] || LogIcons.status }); this.recalculateStats(); return true; }
        removeStatus(type) { if (this.hasStatus(type)) { delete this.statusEffects[type]; UIController.log(`${this.name} の ${type} が治った`, 'log-info', { icon: '✅' }); this.recalculateStats(); } }
        decrementStatusTurns() { for (const type in this.statusEffects) { if(this.statusEffects[type].turns === Infinity) continue; this.statusEffects[type].turns--; if (this.statusEffects[type].turns <= 0) { this.removeStatus(type); } } this.updateDisplay(); }
        async handleStatusEffectsAtTurnEnd() { if (!this.isAlive()) return; let tookDamage = false; if (this.traits.includes(Trait.REGENERATE)) { const regenAmount = Math.max(1, Math.floor(this.maxHp * 0.05)); const healed = this.heal(regenAmount, null, true); if (healed > 0) { UIController.log(`${this.name} は再生した`, 'log-heal', { value: healed, icon: LogIcons.regenerate }); await Utils.delay(ACTION_DELAY * 0.3); } } if (this.hasStatus(StatusEffect.POISON)) { const poisonDamage = Math.max(1, Math.floor(this.maxHp * 0.08)); UIController.log(`${this.name} は ${StatusEffect.POISON} のダメージ`, 'log-damage', { value: poisonDamage, icon: LogIcons.poison }); await this.takeDamage(poisonDamage, Attribute.POISON, null, true, true, false); tookDamage = true; if (!this.isAlive()) return; await Utils.delay(ACTION_DELAY * 0.4); } if (this.hasStatus(StatusEffect.BURN)) { const burnDamage = Math.max(1, Math.floor(this.maxHp * 0.06)); UIController.log(`${this.name} は ${StatusEffect.BURN} のダメージ`, 'log-damage', { value: burnDamage, icon: LogIcons.burn }); await this.takeDamage(burnDamage, Attribute.FIRE, null, true, true, false); tookDamage = true; if (!this.isAlive()) return; await Utils.delay(ACTION_DELAY * 0.4); } if (this.hasStatus(StatusEffect.CURSE)) { const curseDamage = Math.max(1, Math.floor(this.maxHp * 0.04)); UIController.log(`${this.name} は ${StatusEffect.CURSE} のダメージ`, 'log-damage', { value: curseDamage, icon: LogIcons.curse }); await this.takeDamage(curseDamage, Attribute.DARK, null, true, true, false); tookDamage = true; if (!this.isAlive()) return; await Utils.delay(ACTION_DELAY * 0.4); } if (this.isAlive()) { this.decrementStatusTurns(); } }
        async preTurnStatusCheck() { if (!this.isAlive()) return false; if (this.hasStatus(StatusEffect.SLEEP)) { UIController.log(`${this.name} はぐっすり眠っている...`, 'log-status', { icon: LogIcons.sleep }); await Utils.delay(ACTION_DELAY * 0.5); if (this.statusEffects[StatusEffect.SLEEP]?.turns !== Infinity && Math.random() < 0.33) { this.removeStatus(StatusEffect.SLEEP); UIController.log(`${this.name} は目を覚ました！`, 'log-info'); } else { return false; } } if (this.hasStatus(StatusEffect.PARALYSIS)) { if (Math.random() < 0.4) { UIController.log(`${this.name} は体が痺れて動けない！`, 'log-status', { icon: LogIcons.paralysis }); await Utils.delay(ACTION_DELAY * 0.5); return false; } } return true; }
        calculateDamage(skill, target) { if (!target.isAlive() || skill.type === Attribute.HEAL || skill.type === Attribute.SUPPORT) return { damage: 0, isCrit: false, effective: false, message: "" }; let basePower = skill.power || 0; let attackStat = this.currentAtk; let defenseStat = target.currentDef; if (this.hasStatus(StatusEffect.TEMP_ATK_UP)) attackStat *= 1.2; if (skill.attribute === Attribute.FIRE && this.hasStatus(StatusEffect.TEMP_FIRE_UP)) attackStat *= 1.2; let damage = Math.max(1, Math.floor(attackStat * (basePower / 10.0) - defenseStat * 0.5)); let isCrit = Math.random() < 0.05; if (isCrit) { damage = Math.floor(damage * 1.5); } damage = Math.floor(damage * Utils.getRandomInt(90, 110) / 100); let resistanceMultiplier = 1.0; let logEffects = []; let ignoreArmor = false, antiAirBonus = 1.0, undeadSlayerBonus = 1.0; if (skill.tags?.includes('armor_piercing') && target.traits.includes(Trait.ARMOR)) { ignoreArmor = true; logEffects.push(TraitIcons[Trait.ARMOR]+"無視"); } if (skill.tags?.includes('anti_air') && target.traits.includes(Trait.FLYING)) { antiAirBonus = 1.5; logEffects.push(TraitIcons[Trait.FLYING]+"特効"); } if (skill.tags?.includes('undead_slayer') && target.traits.includes(Trait.UNDEAD)) { undeadSlayerBonus = 1.5; logEffects.push(TraitIcons[Trait.UNDEAD]+"特効"); } target.traits.forEach(trait => { let traitMod = 1.0, effectIcon = null; if (trait === Trait.ARMOR && !ignoreArmor && skill.attribute === Attribute.PHYSICAL) { traitMod = 0.7; effectIcon = TraitIcons[Trait.ARMOR]+"耐性"; } if (trait === Trait.MAGIC_RESIST && [Attribute.FIRE, Attribute.ICE, Attribute.HOLY, Attribute.DARK].includes(skill.attribute)) { traitMod = 0.7; effectIcon = TraitIcons[Trait.MAGIC_RESIST]+"耐性"; } if (trait === Trait.FIRE_WEAK && skill.attribute === Attribute.FIRE) { traitMod = 1.5; effectIcon = TraitIcons[Trait.FIRE_WEAK]+"弱点!"; } if (trait === Trait.ICE_IMMUNE && skill.attribute === Attribute.ICE) { traitMod = 0; effectIcon = TraitIcons[Trait.ICE_IMMUNE]+"無効"; } if (trait === Trait.UNDEAD) { if(skill.attribute === Attribute.HOLY) { traitMod = 1.5; effectIcon = TraitIcons[Trait.UNDEAD]+"弱点!"; } if(skill.attribute === Attribute.DARK) { traitMod = 0.5; effectIcon = TraitIcons[Trait.UNDEAD]+"耐性"; } } if(traitMod !== 1.0) { resistanceMultiplier *= traitMod; if(effectIcon && !logEffects.includes(effectIcon)) logEffects.push(effectIcon); } }); if (skill.attribute && target.resistances && target.resistances[skill.attribute] !== undefined) { let attrMod = target.resistances[skill.attribute]; resistanceMultiplier *= attrMod; let effectIcon = null; if(attrMod === 0) effectIcon = `${skill.attribute}${LogIcons.immune}`; else if(attrMod < 1.0) effectIcon = `${skill.attribute}${LogIcons.resistance}`; else if(attrMod > 1.0) effectIcon = `${skill.attribute}${LogIcons.weakness}`; if(effectIcon && !logEffects.includes(effectIcon)) logEffects.push(effectIcon); } damage = Math.max(0, Math.floor(damage * resistanceMultiplier * antiAirBonus * undeadSlayerBonus)); let message = logEffects.join(' '); if (isCrit) message = LogIcons.critical + "クリティカル! " + message; return { damage, isCrit, effective: damage > 0 || antiAirBonus > 1 || undeadSlayerBonus > 1, message: message.trim() }; }
        hitCheck(skill, target) { if (!target?.isAlive()) return true; if (target.traits.includes(Trait.FLYING) && skill.attribute === Attribute.PHYSICAL && !skill.tags?.includes('anti_air')) { if (Math.random() < 0.7) { UIController.log(`${target.name} は攻撃をひらりとかわした！ (飛行)`, 'log-miss', { icon: LogIcons.flying_evade}); UIController.showDamagePopup(target.element, 0, 'miss'); return false; } } return true; }
        async takeDamage(amount, type, sourceActor = null, showAnimation = true, showPopup = true, isCounter = false) { if (!this.isAlive()) return 0; const protector = gameState.battleManager?.findProtector(this); if (protector && !isCounter && type !== Attribute.POISON && type !== Attribute.BURN && type !== Attribute.CURSE) { UIController.log(`${protector.name} が ${this.name} をかばった！`, 'log-info', { icon: LogIcons.protected }); protector.removeStatus(StatusEffect.PROTECTED); return await protector.takeDamage(amount, type, sourceActor, showAnimation, showPopup); } if(this.hasStatus(StatusEffect.SLEEP)) { if (Math.random() < 0.33 || amount > this.maxHp * 0.1) { UIController.log(`${this.name} は攻撃を受けて目を覚ました！`, 'log-info', { icon: '⏰'}); this.removeStatus(StatusEffect.SLEEP); } } const actualDamage = Math.min(this.hp, amount); this.hp -= actualDamage; if (showAnimation && this.element && actualDamage > 0) { this.element.classList.add('taking-damage'); setTimeout(() => this.element?.classList.remove('taking-damage'), DAMAGE_ANIMATION_DURATION); } if (showPopup) { UIController.showDamagePopup(this.element, actualDamage, 'damage'); } this.updateDisplay(); if (!this.isAlive()) { this.handleDeath(sourceActor); } else if (!isCounter && sourceActor && sourceActor.isAlive() && this.traits.includes(Trait.COUNTER) && type === Attribute.PHYSICAL && Math.random() < 0.3) { await Utils.delay(ACTION_DELAY * 0.5); UIController.log(`${this.name} のカウンター！`, this.team === 'player' ? 'log-player' : 'log-opponent', { icon: LogIcons.counter }); const counterSkill = this.skills.find(s => s.type === Attribute.PHYSICAL && s.target.includes('enemy_single')) || SkillDatabase.bite; if (counterSkill && gameState.battleManager) { await this.executeSkill(counterSkill, [sourceActor], gameState.battleManager, true); } } return actualDamage; }
        heal(amount, sourceActor = null, showPopup = true) { if (!this.isAlive()) return 0; if (this.traits.includes(Trait.UNDEAD)) { if (showPopup) UIController.log(`${this.name} は回復を受け付けない (不死)`, 'log-miss', { icon: LogIcons.undead_resist}); return 0; } let healMultiplier = 1.0; if (this.hasStatus(StatusEffect.CURSE)) { healMultiplier = 0.5; UIController.log(`${this.name} は呪われており回復量が半減`, 'log-debuff', { icon: LogIcons.curse }); } const actualHeal = Math.min(Math.floor(amount * healMultiplier), this.maxHp - this.hp); if (actualHeal <= 0) { return 0; } this.hp += actualHeal; if (showPopup) { UIController.showDamagePopup(this.element, actualHeal, 'heal'); } this.updateDisplay(); return actualHeal; }
        handleDeath(killer) { UIController.log(`${this.name} (Lv${this.level}) は倒れた...`, this.team === 'player' ? 'log-opponent' : 'log-player', { icon: LogIcons.lose}); this.hp = 0; this.statusEffects = {}; this.recalculateStats(); if (this.team === 'opponent') { gameFlow.handleEnemyDefeat(this); } }
        recalculateStats() { this.maxHp = this.maxHpBase + this.boostedStats.hp; this.baseAtk = this.baseAtkBase + this.boostedStats.atk; this.baseDef = this.baseDefBase + this.boostedStats.def; this.currentAtk = this.baseAtk; this.currentDef = this.baseDef; if (this.hasStatus(StatusEffect.ATK_UP)) this.currentAtk = Math.round(this.currentAtk * 1.3); if (this.hasStatus(StatusEffect.DEF_UP)) this.currentDef = Math.round(this.currentDef * 1.3); if (this.hasStatus(StatusEffect.DEF_DOWN)) this.currentDef = Math.max(1, Math.round(this.currentDef * 0.7)); this.updateDisplay(); }
        peekNextSkill() { if (!this.isAlive() || this.skills.length === 0) return { name: '(行動不能)', type: Attribute.SUPPORT }; const skillIndex = this.nextSkillIndex % this.skills.length; return this.skills[skillIndex] || { name: '(不明な行動)', type: Attribute.SUPPORT }; }
        getNextSkill() { if (!this.isAlive() || this.skills.length === 0) return null; const skill = this.skills[this.nextSkillIndex % this.skills.length]; this.nextSkillIndex++; return skill; }
        chooseTarget(skill, allies, opponents) { const livingAllies = allies.filter(a => a.isAlive()); const livingOpponents = opponents.filter(o => o.isAlive()); let potentialTargets = []; if (skill.target.includes('enemy')) potentialTargets.push(...livingOpponents); if (skill.target.includes('ally')) potentialTargets.push(...livingAllies); if (skill.target === 'self') potentialTargets = [this]; if (potentialTargets.length === 0) return null; if (skill.target.includes('_all')) return potentialTargets; let preferredTargets = []; if (this.team === 'opponent' && skill.target.includes('enemy')) { const playerTargets = potentialTargets.filter(t => t.team === 'player'); switch (this.aiType) { case AIType.LOW_HP_FOCUS: preferredTargets = playerTargets.sort((a, b) => (a.hp / a.maxHp) - (b.hp / b.maxHp)); break; case AIType.HIGH_ATK_FOCUS: preferredTargets = playerTargets.sort((a, b) => b.currentAtk - a.currentAtk); break; case AIType.HEALER_HUNTER: const healers = playerTargets.filter(t => t.skills.some(s => s.type === Attribute.HEAL)); preferredTargets = healers.length > 0 ? healers.sort((a, b) => (a.hp / a.maxHp) - (b.hp / b.maxHp)) : playerTargets.sort((a, b) => (a.hp / a.maxHp) - (b.hp / b.maxHp)); break; default: preferredTargets = playerTargets.map(t => { const dmgInfo = this.calculateDamage(skill, t); let score = dmgInfo.damage; if (dmgInfo.message.includes('弱点')) score *= 1.5; if (dmgInfo.message.includes('耐性')) score *= 0.7; if (dmgInfo.message.includes('無効')) score = 0; score *= (1.3 - (t.hp / t.maxHp)); return { target: t, score: score }; }).filter(item => item.score > 0).sort((a, b) => b.score - a.score).map(item => item.target); break; } if (preferredTargets.length === 0) preferredTargets = Utils.shuffleArray(playerTargets); } else { switch (skill.type) { case Attribute.HEAL: preferredTargets = potentialTargets.filter(t => t.team === this.team && !t.traits.includes(Trait.UNDEAD)).sort((a, b) => (a.hp / a.maxHp) - (b.hp / b.maxHp)); break; case Attribute.SUPPORT: const effectTargetTeam = skill.target.includes('enemy') ? (this.team === 'player' ? 'opponent' : 'player') : this.team; const isBuff = [StatusEffect.ATK_UP, StatusEffect.DEF_UP, StatusEffect.PROTECTED].includes(skill.effect); preferredTargets = potentialTargets.filter(t => t.team === effectTargetTeam && !t.hasStatus(skill.effect) && !(t.traits.includes(Trait.UNDEAD) && [StatusEffect.SLEEP,StatusEffect.BURN,StatusEffect.CURSE].includes(skill.effect))); if (preferredTargets.length === 0) preferredTargets = potentialTargets.filter(t => t.team === effectTargetTeam); if (skill.target === 'self') preferredTargets = [this]; break; default: preferredTargets = potentialTargets.filter(t => t.team !== this.team); break; } if (preferredTargets.length === 0) preferredTargets = potentialTargets; } return preferredTargets.length > 0 ? preferredTargets[0] : (potentialTargets.length > 0 ? Utils.shuffleArray(potentialTargets)[0] : null); }
        async act(allies, opponents, battleManager) {
            if (!this.isAlive() || battleManager.isBattleEnded) return;
            const canAct = await this.preTurnStatusCheck();
            if (!canAct) { this.element?.classList.remove('active'); return; }
            this.element?.classList.add('active');
            await Utils.delay(ACTION_DELAY / 3);
            let skill = this.getNextSkill();
            if (!skill) { UIController.log(`${this.name} は混乱している！`, 'log-miss', { icon: '❓' }); this.element?.classList.remove('active'); return; }
            const chosenTarget = this.chooseTarget(skill, allies, opponents);
            let targets = [], targetLogName = "";
            if (Array.isArray(chosenTarget)) { targets = chosenTarget; targetLogName = skill.target.includes('enemy') ? "敵全体" : skill.target.includes('ally') ? "味方全体" : "全体"; }
            else if (chosenTarget) { targets = [chosenTarget]; targetLogName = chosenTarget.name; }
            if (targets.length === 0) { UIController.log(`${this.name} は ${skill.name} を使ったが、対象がいなかった...`, 'log-miss', { icon: LogIcons.miss}); }
            else { UIController.log(`${this.name} の ${skill.name} ▶ ${targetLogName}`, this.team === 'player' ? 'log-player' : 'log-opponent', { icon: LogIcons[this.team] }); await this.executeSkill(skill, targets, battleManager); }
            this.element?.classList.remove('active'); this.updateDisplay();
            await Utils.delay(ACTION_DELAY / 2);
        }
        async executeSkill(skill, targets, battleManager, isCounter = false) { if (!skill) { console.warn("executeSkill called with null skill"); return; } for (const target of targets) { if (!target) continue; if (!battleManager.checkBattleContinuation()) break; if (!target.isAlive() && skill.type !== Attribute.SUPPORT && skill.type !== Attribute.HEAL) continue; if (!this.hitCheck(skill, target)) { await Utils.delay(ACTION_DELAY * 0.2); continue; } if (skill.effect === 'remove_poison' && target.hasStatus(StatusEffect.POISON)) { target.removeStatus(StatusEffect.POISON); await Utils.delay(ACTION_DELAY * 0.3); continue; } switch (skill.type) { case Attribute.PHYSICAL: case Attribute.FIRE: case Attribute.ICE: case Attribute.HOLY: case Attribute.DARK: const { damage, isCrit, effective, message } = this.calculateDamage(skill, target); if (effective || damage > 0) { const dmgType = isCrit ? 'critical' : 'damage'; const dmgIcon = isCrit ? LogIcons.critical : LogIcons.damage; UIController.log(`${target.name} に ${damage} ${dmgType === 'critical' ? 'のクリティカル' : ''}ダメージ！ ${message}`, 'log-damage', { icon: dmgIcon, value: damage, effect: message }); await target.takeDamage(damage, skill.attribute, this, true, true, isCounter); if (target.isAlive() && skill.effect && Math.random() < (skill.chance || 1.0)) { target.addStatus(skill.effect, skill.turns || 3, this.uniqueId); } } else { UIController.log(`${target.name} には効果がなかった... ${message}`, 'log-miss', { icon: LogIcons.immune, effect: message }); UIController.showDamagePopup(target.element, 0, 'miss'); } break; case Attribute.DRAIN: const drainInfo = this.calculateDamage(skill, target); if (drainInfo.effective || drainInfo.damage > 0) { const drainType = drainInfo.isCrit ? 'critical' : 'damage'; const drainIcon = drainInfo.isCrit ? LogIcons.critical : LogIcons.damage; UIController.log(`${target.name} に ${drainInfo.damage} ${drainType === 'critical' ? 'のクリティカル' : ''}ダメージ！ ${drainInfo.message}`, 'log-damage', { icon: drainIcon, value: drainInfo.damage, effect: drainInfo.message }); const dealtDamage = await target.takeDamage(drainInfo.damage, skill.attribute, this, true, true, isCounter); if (dealtDamage > 0 && this.isAlive()) { const healAmount = Math.floor(dealtDamage * (skill.drainRate || 0.5)); const actualHeal = this.heal(healAmount, this, true); if (actualHeal > 0) { UIController.log(`${this.name} は HP を ${actualHeal} 吸収した`, 'log-heal', { icon: LogIcons.drain, value: actualHeal }); } } if (target.isAlive() && skill.effect && Math.random() < (skill.chance || 1.0)) { target.addStatus(skill.effect, skill.turns || 3, this.uniqueId); } } else { UIController.log(`${target.name} には効果がなかった... ${drainInfo.message}`, 'log-miss', { icon: LogIcons.immune, effect: drainInfo.message }); UIController.showDamagePopup(target.element, 0, 'miss'); } break; case Attribute.HEAL: const healedAmount = target.heal(skill.power, this); if (healedAmount > 0) { UIController.log(`${target.name} の HP が ${healedAmount} 回復した`, 'log-heal', { icon: LogIcons.heal, value: healedAmount }); } else if (target.isAlive()) {} break; case Attribute.SUPPORT: if (skill.effect) { target.addStatus(skill.effect, skill.turns || 3, this.uniqueId); } else { UIController.log(`${this.name} は ${target.name} に ${skill.name} を使った`, 'log-info', { icon: LogIcons.buff }); } break; default: console.warn(`Unknown skill type: ${skill.type}`); } if (!battleManager.checkBattleContinuation()) break; if (targets.length > 1) await Utils.delay(ACTION_DELAY * 0.3); } }
        addSkill(skillId) { if (this.skills.length < MAX_SKILLS_PER_MONSTER) { const newSkill = SkillDatabase[skillId]; const existingSkill = this.skills.find(s => s.id === skillId); if (newSkill && !existingSkill) { this.skills.push(newSkill); UIController.log(`${this.name} はアビリティ《${newSkill.name}》を習得！`, 'log-win', { icon: '💡'}); UIController.updateSelectedCharacterDetails(); return true; } else if (existingSkill) { UIController.log(`${this.name} は既に ${newSkill.name} を習得済み`, 'log-info'); return false; } } UIController.log(`${this.name} はこれ以上アビリティを習得できない`, 'log-info'); return false; }
        upgradeSkill(skillIndex) { if (skillIndex >= 0 && skillIndex < this.skills.length) { const skill = this.skills[skillIndex]; if (skill.power > 0 && !skill.name.endsWith('+')) { skill.power = Math.round((skill.power || 0) * 1.2 + 5); skill.name += "+"; this.skills[skillIndex] = skill; UIController.log(`${this.name} の《${skill.name.replace('+','')}》が強化された！ (▶ ${skill.name})`, 'log-win', { icon: '⭐'}); UIController.updateSelectedCharacterDetails(); return true; } else { UIController.log(`${skill.name} はこれ以上強化できない`, 'log-info'); } } return false; }
        boostStatus(stat) { let boosted = false, boostValue = 0, icon = '💪', statName = ''; if (stat === 'hp') { statName = '最大HP'; boostValue = Math.round(this.maxHpBase * 0.15 + 10); this.boostedStats.hp += boostValue; boosted = true; icon = '❤️'; } else if (stat === 'atk') { statName = '攻撃力'; boostValue = Math.round(this.baseAtkBase * 0.12 + 3); this.boostedStats.atk += boostValue; boosted = true; icon = '⚔️'; } else if (stat === 'def') { statName = '防御力'; boostValue = Math.round(this.baseDefBase * 0.12 + 3); this.boostedStats.def += boostValue; boosted = true; icon = '🛡️'; } if (boosted) { this.recalculateStats(); if (stat === 'hp') { this.hp = Math.min(this.maxHp, this.hp + boostValue); } UIController.log(`${this.name} の ${statName} が ${boostValue} 上昇！`, 'log-win', { icon: icon }); this.updateDisplay(); } return boosted; }
    } // Character Class End

    // --- Character Database (変更なし) ---
    const CharacterDatabase = {
        p_slime: { id: 'p_slime', name: "プチスライム", hp: 80, atk: 12, def: 10, speed: 11, traits: [Trait.REGENERATE], skills: [SkillDatabase.bite, SkillDatabase.heal_light], description: "最も基本的な使い魔。ぷるぷるしている。自力で少し回復できる。", unlockCost: 10 },
        p_goblin: { id: 'p_goblin', name: "ゴブリン新兵", hp: 90, atk: 14, def: 9, speed: 13, traits: [], skills: [SkillDatabase.slash, SkillDatabase.armor_break], description: "剣を持ったゴブリンの新人。鎧砕きで敵の守りを崩す。", unlockCost: 10 },
        p_fairy: { id: 'p_fairy', name: "フェアリー", hp: 70, atk: 15, def: 8, speed: 15, traits: [Trait.FLYING], skills: [SkillDatabase.ice_shard, SkillDatabase.sleep_cloud], description: "素早く飛び回り、氷の魔法と眠りの粉で敵を翻弄する精霊。", unlockCost: 15 },
        p_golem_core: { id: 'p_golem_core', name: "ゴーレム核", hp: 120, atk: 10, def: 15, speed: 8, traits: [Trait.ARMOR], skills: [SkillDatabase.pierce, SkillDatabase.power_up], description: "ゴーレムの中心核。硬い装甲を持ち、力を溜めて貫通攻撃を放つ。", unlockCost: 25 },
        p_spirit: { id: 'p_spirit', name: "ウィスプ", hp: 75, atk: 16, def: 7, speed: 14, traits: [Trait.MAGIC_RESIST], skills: [SkillDatabase.fireball, SkillDatabase.dark_bolt], description: "魔法エネルギーの塊。魔法への耐性を持ち、炎と闇の魔法を使う。", unlockCost: 20 },
        p_knight: { id: 'p_knight', name: "見習い騎士", hp: 110, atk: 15, def: 13, speed: 10, traits: [], skills: [SkillDatabase.slash, SkillDatabase.protect, SkillDatabase.pierce], description: "騎士を目指す若者。基本的な剣技に加え、味方を守る術も心得ている。", unlockCost: 30 },
        p_angel: { id: 'p_angel', name: "天使見習", hp: 85, atk: 13, def: 10, speed: 14, traits: [Trait.FLYING], skills: [SkillDatabase.holy_light, SkillDatabase.heal_light, SkillDatabase.multi_heal], description: "下級の天使。聖なる光で邪を討ち、味方を癒す力を持つ。", unlockCost: 35 },
        p_skeleton: { id: 'p_skeleton', name: "従僕スケルトン", hp: 95, atk: 15, def: 11, speed: 10, traits: [Trait.UNDEAD, Trait.FIRE_WEAK, Trait.COUNTER], skills: [SkillDatabase.slash, SkillDatabase.armor_break], description: "召喚士に従う骸骨兵士。炎には弱いが、反撃の機会を窺う。", unlockCost: 40 },
        p_orc_fighter: { id: 'p_orc_fighter', name: "オーク闘士", hp: 150, atk: 17, def: 14, speed: 9, traits: [Trait.ARMOR], skills: [SkillDatabase.rampage, SkillDatabase.power_up], description: "戦いを好むオーク。分厚い皮膚を持ち、力を溜めて暴れまわる。", unlockCost: 50 },
        p_mage_apprentice: { id: 'p_mage_apprentice', name: "魔術師の卵", hp: 80, atk: 17, def: 9, speed: 13, traits: [Trait.MAGIC_RESIST], skills: [SkillDatabase.fireball, SkillDatabase.ice_shard, SkillDatabase.curse], description: "魔術を学ぶ若者。基本的な元素魔法に加え、敵を呪う術も習得している。", unlockCost: 45 },
        goblin: { id: 'goblin', name: "ゴブリン", hp: 70, atk: 12, def: 8, speed: 13, traits: [], skills: [SkillDatabase.slash, SkillDatabase.bite], aiType: AIType.NORMAL },
        bat: { id: 'bat', name: "大蝙蝠", hp: 50, atk: 10, def: 5, speed: 16, traits: [Trait.FLYING], skills: [SkillDatabase.bite, SkillDatabase.drain_touch], aiType: AIType.LOW_HP_FOCUS },
        skeleton: { id: 'skeleton', name: "骸骨戦士", hp: 85, atk: 14, def: 10, speed: 9, traits: [Trait.UNDEAD, Trait.FIRE_WEAK], skills: [SkillDatabase.slash, SkillDatabase.armor_break], aiType: AIType.NORMAL },
        poison_snake: { id: 'poison_snake', name: "毒蛇", hp: 60, atk: 11, def: 6, speed: 15, traits: [], skills: [SkillDatabase.bite, SkillDatabase.poison_stab], aiType: AIType.NORMAL },
        orc: { id: 'orc', name: "オーク", hp: 140, atk: 16, def: 13, speed: 8, traits: [Trait.ARMOR], skills: [SkillDatabase.slash, SkillDatabase.pierce, SkillDatabase.rampage], aiType: AIType.HIGH_ATK_FOCUS },
        ice_lizard: { id: 'ice_lizard', name: "氷蜥蜴", hp: 100, atk: 13, def: 12, speed: 11, traits: [Trait.ICE_IMMUNE, Trait.FIRE_WEAK], skills: [SkillDatabase.ice_shard, SkillDatabase.bite], aiType: AIType.NORMAL },
        shadow_beast: { id: 'shadow_beast', name: "影獣", hp: 90, atk: 15, def: 9, speed: 14, traits: [Trait.MAGIC_RESIST, Trait.FLYING], skills: [SkillDatabase.dark_bolt, SkillDatabase.slash, SkillDatabase.curse], aiType: AIType.LOW_HP_FOCUS },
        wyvern: { id: 'wyvern', name: "飛竜", hp: 130, atk: 17, def: 12, speed: 15, traits: [Trait.FLYING, Trait.FIRE_WEAK], skills: [SkillDatabase.sky_strike, SkillDatabase.fire_breath], aiType: AIType.HIGH_ATK_FOCUS },
        lich: { id: 'lich', name: "リッチ", hp: 110, atk: 18, def: 10, speed: 12, traits: [Trait.UNDEAD, Trait.MAGIC_RESIST], skills: [SkillDatabase.dark_bolt, SkillDatabase.sleep_cloud, SkillDatabase.ice_shard, SkillDatabase.curse], aiType: AIType.HEALER_HUNTER },
        golem: { id: 'golem', name: "岩石巨人", hp: 180, atk: 15, def: 18, speed: 7, traits: [Trait.ARMOR], skills: [SkillDatabase.slash, SkillDatabase.pierce, SkillDatabase.power_up, SkillDatabase.rampage], aiType: AIType.NORMAL },
        griffin: { id: 'griffin', name: "グリフォン", hp: 120, atk: 16, def: 11, speed: 17, traits: [Trait.FLYING, Trait.COUNTER], skills: [SkillDatabase.sky_strike, SkillDatabase.paralysis_claw, SkillDatabase.slash], aiType: AIType.HIGH_ATK_FOCUS },
        imp: { id: 'imp', name: "インプ", hp: 65, atk: 12, def: 7, speed: 15, traits: [Trait.FLYING, Trait.FIRE_WEAK], skills: [SkillDatabase.fireball, SkillDatabase.paralysis_claw], aiType: AIType.LOW_HP_FOCUS},
        shaman: { id: 'shaman', name: "ゴブリン魔術師", hp: 80, atk: 14, def: 9, speed: 12, traits: [], skills: [SkillDatabase.fireball, SkillDatabase.heal_light, SkillDatabase.curse], aiType: AIType.HEALER_HUNTER },
    };

    // --- Summon Contract Logic ---
    const summonContract = {
        getUnlockCost: (monsterId) => { const monsterData = CharacterDatabase[monsterId]; return monsterData?.unlockCost || 9999; },
        attemptUnlock: (monsterId) => {
            const monsterData = CharacterDatabase[monsterId];
            if (!monsterData) {
                console.error("Unknown monster ID for summon:", monsterId);
                return;
            }
            const cost = summonContract.getUnlockCost(monsterId);
            if (gameState.unlockedMonsters.includes(monsterId)) {
                console.log(`「${monsterData.name}」は既に契約済みです。`);
                return;
            }
            if (!gameState.summonCandidates.includes(monsterId)) {
                console.log(`「${monsterData.name}」はまだ契約候補になっていません。`);
                return;
            }
            if (account.spendMagicStones(cost)) {
                gameState.unlockedMonsters.push(monsterId);
                const candidateIndex = gameState.summonCandidates.indexOf(monsterId);
                if (candidateIndex > -1) {
                    gameState.summonCandidates.splice(candidateIndex, 1);
                }
                account.savePermanentData();
                console.log(`新たな使い魔「${monsterData.name}」との契約に成功しました！`);
                 UIController.renderSummonContract();
                 party編成.resetPool(); // プール再生成
                 UIController.clearSelectedCharacterDetails(); // 詳細表示をクリア
                 UIController.log(`「${monsterData.name}」と契約しました！`, 'log-win', {icon: LogIcons.unlock});
            } else {
                console.log(`魔石が足りません (必要: ${cost} ${LogIcons.stone})`);
                 UIController.log(`魔石が足りません (必要: ${cost} ${LogIcons.stone})`, 'log-miss', {icon: LogIcons.stone});
            }
        }
    };

    // --- Party Selection Logic (initialize修正) ---
    const party編成 = {
        initialize: () => {
             party編成.resetPool();
             // playerPartyDataは Hub -> Party Selection -> Hub で引き継がれるので、
             // ここで再初期化はせず、既存のデータを使ってレベルなどを反映させる
             if (gameState.playerPartyData && gameState.playerMonsterPool) {
                 gameState.playerPartyData.forEach(partyMember => {
                     const poolMember = gameState.playerMonsterPool.find(pool => pool.baseId === partyMember.baseId);
                     if (poolMember) {
                         // プール側のレベルをパーティデータに合わせる（逆でも良いが、パーティデータが正とする）
                         poolMember.currentLevel = partyMember.level;
                     }
                 });
             }
             UIController.clearSelectedCharacterDetails();
             UIController.renderPartySelection();
         },
        resetPool: () => {
            const baseLevel = 1 + account.getAccountLevelBonus('initialMonsterLevel');
            gameState.playerMonsterPool = gameState.unlockedMonsters
                .filter(id => CharacterDatabase[id])
                .map(id => {
                    // 既存のパーティデータからレベルを取得、なければ基本レベル
                    const existingPartyMember = gameState.playerPartyData.find(p => p.baseId === id);
                    const level = existingPartyMember ? existingPartyMember.level : (baseLevel + Utils.getRandomInt(0, 1));
                    return { baseId: id, currentLevel: level };
                });
        },
        handlePartyChange: (baseId) => {
            const currentPartyBaseIds = gameState.playerPartyData.map(p => p.baseId);
            const index = currentPartyBaseIds.indexOf(baseId);
            if (index > -1) { // パーティから外す
                const removed = gameState.playerPartyData.splice(index, 1);
                if (removed[0]?.uniqueId === gameState.selectedCharacterId) {
                    UIController.clearSelectedCharacterDetails();
                }
                console.log(`${CharacterDatabase[baseId]?.name || baseId} をパーティから外しました。`);
            } else { // パーティに追加する
                if (gameState.playerPartyData.length < PLAYER_PARTY_SIZE) {
                    const poolEntry = gameState.playerMonsterPool.find(p => p.baseId === baseId);
                    const baseData = CharacterDatabase[baseId];
                    if(poolEntry && baseData) {
                        // BaseDataから初期スキルIDリストを取得
                        const initialSkillIds = (baseData.skills || []).map(s => s.id).filter(Boolean);
                        gameState.playerPartyData.push({
                            baseId: poolEntry.baseId,
                            level: poolEntry.currentLevel,
                            skills: initialSkillIds, // BaseDataのスキルを初期スキルとする
                            uniqueId: `p-uuid-${partyMemberCounter++}`,
                            boostedStats: { hp: 0, atk: 0, def: 0 } // 新規追加時はブーストなし
                        });
                        console.log(`${baseData.name} をパーティに追加しました。`);
                    } else {
                        console.warn("Could not find monster in pool or database:", baseId);
                    }
                } else {
                    console.log(`パーティは${PLAYER_PARTY_SIZE}体までです`);
                    UIController.log(`パーティは${PLAYER_PARTY_SIZE}体までです`, 'log-info');
                }
            }
            party編成.resetPool(); // プールのレベルを最新のパーティデータに合わせる
            UIController.renderPartySelection(); // UI再描画
        },
        confirmParty: () => {
            if (gameState.playerPartyData.length === PLAYER_PARTY_SIZE) {
                gameState.playerPartyLevel = Math.max(1, Math.floor(gameState.playerPartyData.reduce((sum, p) => sum + p.level, 0) / PLAYER_PARTY_SIZE));
                console.log("パーティ編成完了！拠点に戻ります。");
                gameFlow.returnToHub();
            } else {
                console.log(`パーティは${PLAYER_PARTY_SIZE}体編成してください`);
                UIController.log(`パーティは${PLAYER_PARTY_SIZE}体編成してください`, 'log-miss');
            }
        }
    };

    // --- Battle Manager (endBattle修正) ---
    class BattleManager {
        constructor(playerParty, opponentParty) {
            this.playerParty = playerParty; this.opponentParty = opponentParty;
            this.turnOrder = []; this.currentTurnIndex = 0; this.turnCount = 0;
            this.isBattleEnded = false; gameState.isBattleEnded = false; // Reset global flag
            this.applyTemporaryBuffs();
            this.setupPartyArea(DOMElements.playerPartyArea, this.playerParty);
            this.setupPartyArea(DOMElements.opponentPartyArea, this.opponentParty);
            const oppArea = DOMElements.opponentPartyArea;
            oppArea.classList.remove('many-units', 'very-many-units');
            if (this.opponentParty.length >= 7) oppArea.classList.add('very-many-units');
            else if (this.opponentParty.length >= 5) oppArea.classList.add('many-units');
            console.log("BattleManager initialized. Player:", this.playerParty.length, "Opponent:", this.opponentParty.length);
        }
        setupPartyArea(areaElement, party) { if (!areaElement) { console.error("setupPartyArea: areaElement is null or undefined."); return; } areaElement.innerHTML = ''; party.forEach(character => { const card = character.render(); areaElement.appendChild(card); }); }
        applyTemporaryBuffs() { const buffs = gameState.temporaryBuffs; if (Object.keys(buffs).length > 0) { UIController.log("--- 前階層からのボーナス効果発動！ ---", "log-buff", {icon: '✨'}); this.playerParty.forEach(p => { if (buffs[StatusEffect.TEMP_ATK_UP] > 0) { p.addStatus(StatusEffect.TEMP_ATK_UP, Infinity); UIController.log(`${p.name} の攻撃力が上昇！`, 'log-buff'); } if (buffs[StatusEffect.TEMP_FIRE_UP] > 0) { p.addStatus(StatusEffect.TEMP_FIRE_UP, Infinity); UIController.log(`${p.name} の炎攻撃が強化！`, 'log-buff'); } }); } }
        clearTemporaryBuffs() { const tempBuffTypes = [StatusEffect.TEMP_ATK_UP, StatusEffect.TEMP_FIRE_UP]; this.playerParty.forEach(p => tempBuffTypes.forEach(buffType => p.removeStatus(buffType))); console.log("Temporary buffs cleared."); }
        decrementTemporaryBuffsDuration() { const buffs = gameState.temporaryBuffs; let changed = false; for (const type in buffs) { if (buffs[type] > 0) { buffs[type]--; changed = true; if (buffs[type] <= 0) { delete buffs[type]; console.log(`Temporary buff ${type} expired.`); } } } }
        determineTurnOrder() { const allCharacters = [...this.playerParty, ...this.opponentParty]; this.turnOrder = allCharacters.filter(char => char.isAlive()).sort((a, b) => b.speed - a.speed || Math.random() - 0.5); this.currentTurnIndex = 0; this.turnCount++; UIController.log(`--- ターン ${this.turnCount} 開始 ---`, 'log-turn', { icon: LogIcons.turn }); this.updateAllCharacterDisplays(); }
        async startBattlePhase() {
            gameState.currentPhase = GamePhase.BATTLE;
            UIController.switchScreen(GamePhase.BATTLE);
            UIController.clearLog(); // Also resets isBattleEnded and scrollBehavior
            UIController.log(`--- 第 ${gameState.currentWave} 階層 戦闘開始！ ---`, 'log-system', { icon: LogIcons.system });
            this.determineTurnOrder();
            this.isBattleEnded = false; // Ensure internal flag is false at start
            gameState.isBattleEnded = false; // Ensure global flag is false at start
            UIController.updatePartyInfoSidebar();
            await Utils.delay(300);
            this.nextStep();
        }
        async nextStep() { if (this.isBattleEnded || gameState.isBattleEnded) return; if (this.currentTurnIndex >= this.turnOrder.length) { await this.endTurn(); if (!this.isBattleEnded && !gameState.isBattleEnded) { this.determineTurnOrder(); await Utils.delay(TURN_END_DELAY); this.nextStep(); } return; } const currentActor = this.turnOrder[this.currentTurnIndex]; if (currentActor && currentActor.isAlive()) { await currentActor.act( currentActor.team === 'player' ? this.playerParty : this.opponentParty, currentActor.team === 'player' ? this.opponentParty : this.playerParty, this ); } if (!this.isBattleEnded && !gameState.isBattleEnded && !this.checkBattleContinuation()) { this.endBattle(); return; } if (!this.isBattleEnded && !gameState.isBattleEnded) { this.currentTurnIndex++; UIController.updatePartyInfoSidebar(); await Utils.delay(ACTION_DELAY); this.nextStep(); } }
        async endTurn() { UIController.log(`--- ターン ${this.turnCount} 終了処理 ---`, 'log-system', { icon: LogIcons.system }); const turnOrderAtEndOfTurn = [...this.turnOrder]; for (const char of turnOrderAtEndOfTurn) { if (char.isAlive() && !this.isBattleEnded && !gameState.isBattleEnded) { await char.handleStatusEffectsAtTurnEnd(); if (!this.checkBattleContinuation()) { this.endBattle(); return; } } } if (!this.isBattleEnded && !gameState.isBattleEnded) UIController.log(`ターン ${this.turnCount} 終了`, 'log-system', { icon: LogIcons.system }); UIController.updatePartyInfoSidebar(); }
        checkBattleContinuation() { return this.playerParty.some(c => c.isAlive()) && this.opponentParty.some(c => c.isAlive()); }
        endBattle() {
            if (this.isBattleEnded || gameState.isBattleEnded) return; // Prevent double execution
            console.log("endBattle called");
            gameState.isBattleEnded = true; // Set global flag first
            this.isBattleEnded = true;    // Set internal flag

            // Disable smooth scroll for log area
            if (DOMElements.logArea) {
                 DOMElements.logArea.style.scrollBehavior = 'auto';
                 // Ensure the last log message is visible
                 setTimeout(() => DOMElements.logArea.scrollTop = DOMElements.logArea.scrollHeight, 50);
            } else {
                 console.warn("Log area element not found in endBattle.");
            }

            this.clearTemporaryBuffs();
            this.playerParty.forEach(p => p.element?.classList.remove('active'));
            this.opponentParty.forEach(o => o.element?.classList.remove('active'));
            const playerWon = this.playerParty.some(char => char.isAlive());

            if (playerWon) {
                UIController.log(`--- 第 ${gameState.currentWave} 階層 クリア！ ---`, 'log-win', { icon: LogIcons.win });
                const expGainMultiplier = account.getAccountLevelBonus('expGainMultiplier');
                const expGained = Math.floor(this.opponentParty.reduce((sum, opp) => sum + (opp.level * 5 + 10), 0) * expGainMultiplier);
                gameState.playerTotalExpInRun += expGained;
                UIController.log(`${Utils.formatNumber(expGained)} 魂片獲得 (今回の探索合計: ${Utils.formatNumber(gameState.playerTotalExpInRun)})`, 'log-info', { icon: '✨'});
                const stoneGainMultiplier = account.getAccountLevelBonus('stoneGainMultiplier');
                const baseStoneGain = Math.floor(Utils.getRandomInt(1, 3) * Math.pow(gameState.currentWave, 0.6) + this.opponentParty.length);
                const stonesGained = Math.max(1, Math.floor(baseStoneGain * stoneGainMultiplier));
                gameState.playerTotalStonesInRun += stonesGained;
                UIController.log(`${Utils.formatNumber(stonesGained)} 魔石獲得 (今回の探索合計: ${Utils.formatNumber(gameState.playerTotalStonesInRun)})`, 'log-info', { icon: LogIcons.stone });
                UIController.updateGameInfo();

                const buttonsContainer = DOMElements.battleActionButtons;
                if (buttonsContainer) {
                    buttonsContainer.innerHTML = ''; // Clear previous buttons if any
                    const rewardButton = document.createElement('button');
                    rewardButton.id = 'go-to-reward-button';
                    rewardButton.textContent = '報酬を確認する';
                    rewardButton.onclick = () => {
                        console.log("報酬確認ボタンクリック！");
                        gameState.currentPhase = GamePhase.REWARD_SELECT;
                        rewardSystem.generateAndShowRewards();
                        rewardButton.remove(); // Remove button after click
                    };
                    buttonsContainer.appendChild(rewardButton);
                    console.log("報酬確認ボタンが追加されました。");
                } else {
                    console.error("!!! battleActionButtons container not found.");
                     // Fallback if button container is missing (should not happen)
                     setTimeout(() => {
                         gameState.currentPhase = GamePhase.REWARD_SELECT;
                         rewardSystem.generateAndShowRewards();
                     }, 1500);
                }

            } else {
                console.log("プレイヤー敗北 - handleGameOver 呼び出し");
                setTimeout(() => {
                    gameFlow.handleGameOver();
                }, 1000);
            }
        }
        findProtector(targetCharacter) { if (!targetCharacter || targetCharacter.team !== 'player') return null; return this.playerParty.find(ally => ally.isAlive() && ally.hasStatus(StatusEffect.PROTECTED)); }
        updateAllCharacterDisplays() { [...this.playerParty, ...this.opponentParty].forEach(char => char.updateDisplay()); }
        getPlayerPartyDataForSave() { return this.playerParty.map(p => ({ baseId: p.baseId, level: p.level, skills: p.skills.map(s => s.id || Object.keys(SkillDatabase).find(key => SkillDatabase[key].name === s.name.replace(/\+*$/,'')) || 'unknown'), uniqueId: p.uniqueId, boostedStats: { ...p.boostedStats } })); }
    } // BattleManager End

    // --- UI Controller (ログ自動スクロール修正、詳細表示修正) ---
    const UIController = {
        tooltipTimeout: null,
        log: (message, type = 'log-system', details = null) => {
            const logList = DOMElements.logList;
            const logArea = DOMElements.logArea;
            if (!logList || !logArea) return;

            const li = document.createElement('li');
            const iconSpan = document.createElement('span'); iconSpan.classList.add('log-icon'); iconSpan.textContent = details?.icon || LogIcons[type.toLowerCase().replace('log-','')] || '💬'; li.appendChild(iconSpan);
            const messageSpan = document.createElement('span'); messageSpan.classList.add('log-message'); let formattedMessage = message; formattedMessage = formattedMessage.replace(/(\d+)(?: のクリティカル)? ダメージ/g, (match, p1) => { const isCrit = match.includes('クリティカル'); return `<span class="log-value ${isCrit ? 'log-critical' : ''}">${Utils.formatNumber(parseInt(p1))}</span>${isCrit ? ' のクリティカル' : ''} ダメージ`; }); formattedMessage = formattedMessage.replace(/HP を (\d+) (吸収|回復)/g, (match, p1, p2) => { return `HP を <span class="log-value log-heal">${Utils.formatNumber(parseInt(p1))}</span> ${p2}`; }); formattedMessage = formattedMessage.replace(/(弱点!)/g, '<span class="log-weakness">$1</span>'); formattedMessage = formattedMessage.replace(/(耐性)/g, '<span class="log-resistance">$1</span>'); formattedMessage = formattedMessage.replace(/(無効)/g, '<span class="log-immune">$1</span>'); formattedMessage = formattedMessage.replace(/(回避！)/g, '<span class="log-miss">$1</span>'); Object.keys(StatusEffect).forEach(key => { const statusName = StatusEffect[key]; const regex = new RegExp(`(${statusName})`, 'g'); formattedMessage = formattedMessage.replace(regex, `<span class="log-status-name">$1</span>`); }); if (type === 'log-flavor') li.classList.add('log-flavor'); if (type === 'log-tutorial') li.classList.add('log-tutorial'); messageSpan.innerHTML = formattedMessage; li.appendChild(messageSpan); if(details?.value !== undefined) { const valueSpan = document.createElement('span'); valueSpan.classList.add('log-detail'); valueSpan.textContent = `(${Utils.formatNumber(details.value)})`; li.appendChild(valueSpan); } if(details?.effect) { const effectSpan = document.createElement('span'); effectSpan.classList.add('log-effect'); let formattedEffect = details.effect; formattedEffect = formattedEffect.replace(/(弱点!)/g, '<span class="log-weakness">$1</span>').replace(/(耐性)/g, '<span class="log-resistance">$1</span>').replace(/(無効)/g, '<span class="log-immune">$1</span>').replace(/特効/g, '<span class="log-weakness">特効</span>'); effectSpan.innerHTML = `(${formattedEffect})`; li.appendChild(effectSpan); } li.classList.add(type);
            logList.appendChild(li);

            // 戦闘中のみスムーズスクロール
            if (!gameState.isBattleEnded && logArea.style.scrollBehavior !== 'auto') {
                 logArea.scrollTo({ top: logArea.scrollHeight, behavior: 'smooth' });
            } else {
                 // 戦闘終了後や手動スクロール後は一番下へ移動（スムーズなし）
                 logArea.scrollTop = logArea.scrollHeight;
            }
        },
        clearLog: () => {
            if (DOMElements.logList) DOMElements.logList.innerHTML = '';
            // ログクリア時にスクロール挙動をスムーズに戻す
            if (DOMElements.logArea) DOMElements.logArea.style.scrollBehavior = 'smooth';
            gameState.isBattleEnded = false; // ログクリア時は戦闘もリセットされているはず
        },
        showDamagePopup: (element, amount, type = 'damage') => { if (!element || !element.isConnected) return; const popup = document.createElement('span'); popup.textContent = type === 'miss' ? 'Miss' : Utils.formatNumber(amount); popup.classList.add('damage-popup', type); if(type === 'critical') popup.classList.add('critical'); element.appendChild(popup); setTimeout(() => { if (popup.parentNode) popup.parentNode.removeChild(popup); }, POPUP_DURATION); },
        switchScreen: (phase) => {
            console.log("Switching screen to:", phase); gameState.currentPhase = phase;
            const activeScreenClass = 'active';
            const isScreenActive = Object.values(DOMElements.screens).some(screen => screen?.classList.contains(activeScreenClass));
            const isRewardActive = DOMElements.rewardModal?.classList.contains(activeScreenClass);
            const isResultActive = DOMElements.resultScreen?.classList.contains(activeScreenClass);
            const animationDelay = (isScreenActive || isRewardActive || isResultActive) ? 150 : 0;

            // Deactivate all screens and modals first
            Object.values(DOMElements.screens).forEach(screen => screen?.classList.remove(activeScreenClass));
            DOMElements.rewardModal?.classList.remove(activeScreenClass);
            DOMElements.resultScreen?.classList.remove(activeScreenClass);

            // Hide all grid columns initially
            const allGridColumns = [
                DOMElements.hubScreenCol1, DOMElements.hubScreenCol2, DOMElements.hubScreenCol3, DOMElements.hubScreenCol4,
                DOMElements.summonContractScreenCol1, DOMElements.summonContractScreenCol3, DOMElements.summonContractScreenCol4,
                DOMElements.partyScreenCol1, DOMElements.partyScreenCol2, DOMElements.partyScreenCol3, DOMElements.partyScreenCol4,
                DOMElements.battleScreenCol1, DOMElements.battleScreenCol2, DOMElements.battleScreenCol3, DOMElements.battleScreenCol4
            ];
            allGridColumns.forEach(col => { if (col) col.style.display = 'none'; });

            // Hide detail panels explicitely
             Object.values(DOMElements.hubDetailsPanel).forEach(el => el?.container?.classList?.add('hidden'));
             Object.values(DOMElements.summonDetailsPanel).forEach(el => el?.container?.classList?.add('hidden'));
             Object.values(DOMElements.partyDetailsPanel).forEach(el => el?.container?.classList?.add('hidden'));
             Object.values(DOMElements.battleDetailsPanel).forEach(el => el?.container?.classList?.add('hidden'));


            setTimeout(() => {
                // Set display none for all inactive screens/modals
                Object.values(DOMElements.screens).forEach(screen => { if(screen && !screen.classList.contains(activeScreenClass)) screen.style.display = 'none'; });
                if (DOMElements.rewardModal && !DOMElements.rewardModal.classList.contains(activeScreenClass)) DOMElements.rewardModal.style.display = 'none';
                if (DOMElements.resultScreen && !DOMElements.resultScreen.classList.contains(activeScreenClass)) DOMElements.resultScreen.style.display = 'none';

                // Hide flavor area and log area initially
                if (DOMElements.column4FlavorArea) DOMElements.column4FlavorArea.classList.remove('active');
                if (DOMElements.logAreaContainer) DOMElements.logAreaContainer.style.display = 'none';
                if (DOMElements.battleActionButtons) DOMElements.battleActionButtons.innerHTML = ''; // Clear battle buttons

                let targetElement = null;
                let displayType = 'flex'; // Default for non-grid screens

                // Determine target screen/modal
                if (phase === GamePhase.REWARD_SELECT) { targetElement = DOMElements.rewardModal; }
                else if (phase === GamePhase.RESULT) { targetElement = DOMElements.resultScreen; }
                else if (DOMElements.screens[phase]) {
                    targetElement = DOMElements.screens[phase];
                     // Set display type for grid-based screens
                     if ([GamePhase.HUB, GamePhase.SUMMON_CONTRACT, GamePhase.PARTY_SELECT, GamePhase.BATTLE].includes(phase)) {
                        displayType = 'contents';
                     }
                } else { console.error("Target screen/modal not found for phase:", phase); return; }

                if (!targetElement) { console.error("Target element is null for phase:", phase); return; }

                // Activate the target screen/modal
                targetElement.style.display = displayType;
                void targetElement.offsetWidth; // Trigger reflow for transition
                targetElement.classList.add(activeScreenClass);

                // Handle grid column visibility and specific screen setup
                if (displayType === 'contents') {
                    const colsToShow = [];
                    switch(phase) {
                        case GamePhase.HUB:
                            colsToShow.push(DOMElements.hubScreenCol1, DOMElements.hubScreenCol2, DOMElements.hubScreenCol3, DOMElements.hubScreenCol4);
                            UIController.updateHubScreen();
                            if(DOMElements.hubDetailsPanel.container) DOMElements.hubDetailsPanel.container.classList.remove('hidden'); // Show hub detail panel container
                            break;
                        case GamePhase.SUMMON_CONTRACT:
                            colsToShow.push(DOMElements.summonContractScreenCol1, DOMElements.summonContractScreenCol3, DOMElements.summonContractScreenCol4);
                            UIController.renderSummonContract();
                            if(DOMElements.summonDetailsPanel.container) DOMElements.summonDetailsPanel.container.classList.remove('hidden'); // Show summon detail panel container
                            break;
                        case GamePhase.PARTY_SELECT:
                            colsToShow.push(DOMElements.partyScreenCol1, DOMElements.partyScreenCol2, DOMElements.partyScreenCol3, DOMElements.partyScreenCol4);
                            party編成.initialize();
                            if(DOMElements.partyDetailsPanel.container) DOMElements.partyDetailsPanel.container.classList.remove('hidden'); // Show party detail panel container
                            break;
                        case GamePhase.BATTLE:
                            colsToShow.push(DOMElements.battleScreenCol1, DOMElements.battleScreenCol2, DOMElements.battleScreenCol3, DOMElements.battleScreenCol4);
                            if(DOMElements.logAreaContainer) DOMElements.logAreaContainer.style.display = 'flex'; // Show log area
                            UIController.updatePartyInfoSidebar();
                            gameState.isBattleEnded = false; // Reset battle end flag for new battle
                            if(DOMElements.logArea) DOMElements.logArea.style.scrollBehavior = 'smooth'; // Enable smooth scroll for new battle
                            // Battle detail panel visibility controlled by selection
                            break;
                    }
                    colsToShow.forEach(col => { if (col) col.style.display = 'flex'; });

                    // Show flavor text area for these screens
                    if ([GamePhase.HUB, GamePhase.SUMMON_CONTRACT, GamePhase.PARTY_SELECT, GamePhase.BATTLE].includes(phase)) {
                         if(DOMElements.column4FlavorArea) DOMElements.column4FlavorArea.classList.add('active');
                         UIController.displayFlavorText();
                         UIController.clearSelectedCharacterDetails(); // Clear details when switching to these screens
                     }
                } else if (phase === GamePhase.SETUP || phase === GamePhase.READY_TO_START) {
                     // Non-grid screens, just clear details
                     UIController.clearSelectedCharacterDetails();
                }

                // Control header visibility
                const showHeaderInfo = ![GamePhase.TITLE].includes(phase);
                DOMElements.gameInfoHeader?.classList.toggle('active', showHeaderInfo);
                console.log("Screen/Modal activated:", targetElement.id || `Phase: ${phase}`);
            }, animationDelay);
        },
        setupTitleScreen: () => { account.loadPermanentData(); gameState.highestFloor = parseInt(localStorage.getItem(HIGHEST_FLOOR_KEY) || '0'); DOMElements.highestFloorDisplay.textContent = `最高到達階層: ${gameState.highestFloor}`; if (localStorage.getItem(SAVE_DATA_KEY)) { DOMElements.continueGameButton.classList.remove('hidden'); DOMElements.continueGameButton.disabled = false; } else { DOMElements.continueGameButton.classList.add('hidden'); DOMElements.continueGameButton.disabled = true; } UIController.updateGameInfo(); },
        updateHubScreen: () => {
            const partyReady = gameState.playerPartyData && gameState.playerPartyData.length === PLAYER_PARTY_SIZE;
            if(DOMElements.hubChallengeButton) DOMElements.hubChallengeButton.disabled = !partyReady;
            const partyListUl = DOMElements.hubPartyList;
            if (partyListUl && gameState.playerPartyData) {
                partyListUl.innerHTML = '';
                if (gameState.playerPartyData.length > 0) {
                    gameState.playerPartyData.forEach(pData => {
                        const baseData = CharacterDatabase[pData.baseId];
                        const li = document.createElement('li');
                        li.dataset.baseId = pData.baseId;
                        li.dataset.uniqueId = pData.uniqueId;
                        const icon = baseData ? (TraitIcons[baseData.traits?.[0]] || '❔') : '❔';
                        li.innerHTML = `<span class="icon">${icon}</span> <span class="name">${baseData?.name || '?'}</span> <span class="level">Lv${pData.level}</span>`;
                        // Click listener added via delegation in initialize
                        if (pData.uniqueId === gameState.selectedCharacterId) {
                             li.classList.add('selected-in-detail');
                        }
                        partyListUl.appendChild(li);
                    });
                    partyListUl.parentElement.classList.remove('hidden'); // Show container
                } else {
                     // Show placeholder or hide list if empty
                     const placeholderLi = document.createElement('li');
                     placeholderLi.textContent = 'パーティメンバーがいません';
                     placeholderLi.style.textAlign = 'center';
                     placeholderLi.style.color = 'var(--text-dark)';
                     partyListUl.appendChild(placeholderLi);
                     // partyListUl.parentElement.classList.add('hidden'); // Optionally hide if truly empty
                }
            } else if (partyListUl) {
                 // Should not happen if element exists, but handle defensively
                 partyListUl.parentElement.classList.add('hidden');
            }
         },
        renderSummonContract: () => { if (!DOMElements.summonList || !DOMElements.summonStoneCount || !DOMElements.summonListPlaceholder || !DOMElements.summonResourceInfo) return; DOMElements.summonResourceInfo.innerHTML = `所持魔石: <strong id="summon-stone-count">${Utils.formatNumber(gameState.magicStones)}</strong> <span title="魔石">💎</span>`; DOMElements.summonList.innerHTML = ''; const summonableCandidates = gameState.summonCandidates.filter(candidateId => !gameState.unlockedMonsters.includes(candidateId) && CharacterDatabase[candidateId]); summonableCandidates.sort((aId, bId) => (CharacterDatabase[aId].unlockCost || 999) - (CharacterDatabase[bId].unlockCost || 999)); if (summonableCandidates.length === 0) { DOMElements.summonListPlaceholder.textContent = "契約可能な候補がいません。塔で新たな出会いを探しましょう。"; DOMElements.summonListPlaceholder.classList.remove('hidden'); DOMElements.summonListContainer.style.justifyContent = 'center'; return; } DOMElements.summonListPlaceholder.classList.add('hidden'); DOMElements.summonListContainer.style.justifyContent = 'flex-start'; summonableCandidates.forEach(monsterId => { const monster = CharacterDatabase[monsterId]; const li = document.createElement('li'); li.classList.add('summon-list-item'); li.dataset.baseId = monster.id; const tempUniqueId = `s-cand-${monster.id}`; li.dataset.uniqueId = tempUniqueId; const cost = monster.unlockCost; const canAfford = gameState.magicStones >= cost; const icon = TraitIcons[monster.traits?.[0]] || '❔'; li.innerHTML = `<span><span class="list-icon">${icon}</span> ${monster.name}</span><div class="summon-cost"><span>コスト: <strong style="${canAfford ? '' : 'color: var(--accent-red);'}">${Utils.formatNumber(cost)}</strong> <span title="魔石">💎</span></span><button class="summon-btn" data-monster-id="${monster.id}" ${canAfford ? '' : 'disabled'}>契約する</button></div>`; /* Click listener for li added via delegation */ if (tempUniqueId === gameState.selectedCharacterId) { li.classList.add('selected-in-detail'); } DOMElements.summonList.appendChild(li); }); },
        renderPartySelection: () => { const poolList = DOMElements.monsterPoolList; const partyList = DOMElements.currentPartyList; if (!poolList || !partyList) return; poolList.innerHTML = ''; partyList.innerHTML = ''; const currentPartyBaseIds = gameState.playerPartyData.map(p => p.baseId); const selectedPoolBaseId = gameState.selectedCharacterId?.startsWith('p-pool-') ? gameState.selectedCharacterId.substring(7) : null; const sortedUnlockedIds = Object.keys(CharacterDatabase).filter(id => id.startsWith('p_') && gameState.unlockedMonsters.includes(id)); const monsterPoolToRender = sortedUnlockedIds.map(id => gameState.playerMonsterPool.find(p => p.baseId === id)).filter(Boolean); monsterPoolToRender.forEach(poolMonster => { const baseData = CharacterDatabase[poolMonster.baseId]; if (!baseData) return; const level = poolMonster.currentLevel; const isInParty = currentPartyBaseIds.includes(poolMonster.baseId); const li = document.createElement('li'); li.classList.add('monster-list-item'); li.dataset.baseId = poolMonster.baseId; const icon = TraitIcons[baseData.traits?.[0]] || '❔'; const poolUniqueId = `p-pool-${poolMonster.baseId}`; li.dataset.uniqueId = poolUniqueId; li.innerHTML = `<span><span class="list-icon">${icon}</span> ${baseData.name}</span><span class="level">Lv${level}</span><button class="add-remove-btn ${isInParty ? 'remove-btn' : 'add-btn'}" data-action="${isInParty ? 'remove' : 'add'}">${isInParty ? '外す' : '追加'}</button>`; /* Click listener for li added via delegation */ li.querySelector('button').addEventListener('click', (e) => { e.stopPropagation(); party編成.handlePartyChange(poolMonster.baseId); }); if (poolMonster.baseId === selectedPoolBaseId) li.classList.add('selected-in-detail'); if (isInParty) li.classList.add('selected-for-party'); poolList.appendChild(li); }); gameState.playerPartyData.forEach(partyEntry => { const baseData = CharacterDatabase[partyEntry.baseId]; if (!baseData) return; const li = document.createElement('li'); li.classList.add('monster-list-item', 'selected-for-party'); li.dataset.baseId = partyEntry.baseId; li.dataset.uniqueId = partyEntry.uniqueId; const icon = TraitIcons[baseData.traits?.[0]] || '❔'; li.innerHTML = `<span><span class="list-icon">${icon}</span> ${baseData.name}</span><span class="level">Lv${partyEntry.level}</span><button class="add-remove-btn remove-btn" data-action="remove">外す</button>`; /* Click listener for li added via delegation */ li.querySelector('button').addEventListener('click', (e) => { e.stopPropagation(); party編成.handlePartyChange(partyEntry.baseId); }); if (partyEntry.uniqueId === gameState.selectedCharacterId || (gameState.selectedCharacterId?.startsWith('p-pool-') && gameState.selectedCharacterId.substring(7) === partyEntry.baseId)) { li.classList.add('selected-in-detail'); } partyList.appendChild(li); }); DOMElements.currentPartyCount.textContent = gameState.playerPartyData.length; DOMElements.confirmPartyButton.disabled = gameState.playerPartyData.length !== PLAYER_PARTY_SIZE; },
        highlightSelectedDetailInList: (uniqueId) => {
            // Remove highlight from all potential list items first
            document.querySelectorAll('.monster-list-item.selected-in-detail, #hub-party-list li.selected-in-detail, .summon-list-item.selected-in-detail, .character-card.selected-for-detail').forEach(el => el.classList.remove('selected-in-detail'));
            document.querySelectorAll('.character-card.selected-for-detail').forEach(el => el.classList.remove('selected-for-detail')); // Explicitly remove from cards too
            if(uniqueId) {
                // Find the element in the lists or battle area
                const targetElement = document.querySelector(`[data-unique-id="${uniqueId}"]`) || document.getElementById(uniqueId);
                if(targetElement) {
                    // Determine the correct class based on context
                    const listSelector = '.monster-list-item, #hub-party-list li, .summon-list-item';
                    const cardSelector = '.character-card';
                    if (targetElement.matches(listSelector)) {
                        targetElement.classList.add('selected-in-detail');
                    } else if (targetElement.matches(cardSelector)) {
                        targetElement.classList.add('selected-for-detail'); // Use the specific class for cards
                    }
                    // Scroll into view if it's in a scrollable list
                    const scrollableParent = targetElement.closest('#monster-pool-list-container, #current-party-list-container, #hub-party-list, #summon-list-container, .party-area');
                    if (scrollableParent) {
                        targetElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    }
                }
            }
         },
        setupReadyScreen: () => { const partyListEl = DOMElements.readyPartySummary?.querySelector('ul'); if (!partyListEl) return; partyListEl.innerHTML = gameState.playerPartyData.map(p => { const data = CharacterDatabase[p.baseId]; const icon = data ? (TraitIcons[data.traits?.[0]] || '❔') : '❔'; return `<li><span class="icon">${icon}</span> ${data?.name || '?'} (Lv${p.level})</li>`; }).join(''); },
        setupSetupPhaseUI: (wave, opponents, playerParty) => { DOMElements.setupWaveNumber.textContent = wave; DOMElements.enemyListDiv.innerHTML = opponents.map(opp => { const icon = TraitIcons[opp.traits?.[0]] || '❔'; return `<span><span class="icon">${icon}</span> ${opp.name} (Lv.${opp.level})</span>`; }).join(''); },
        updateGameInfo: () => { if (DOMElements.waveCountInfo) DOMElements.waveCountInfo.textContent = gameState.currentWave; if (DOMElements.accountLevelInfo) DOMElements.accountLevelInfo.textContent = gameState.playerAccountLevel; if (DOMElements.playerLevelInfo) DOMElements.playerLevelInfo.textContent = gameState.playerPartyLevel; if (DOMElements.expToNextInfo && DOMElements.expTooltipWrapper) { let expForCurrentLevelTotal = 0; for(let i = 0; i < gameState.playerAccountLevel; i++) { expForCurrentLevelTotal += Utils.getExpForNextAccountLevel(i); } const expNeeded = Utils.getExpForNextAccountLevel(gameState.playerAccountLevel); const currentLevelExp = Math.max(0, gameState.playerAccountTotalExp - expForCurrentLevelTotal); const remainingExp = Math.max(0, expNeeded - currentLevelExp); DOMElements.expToNextInfo.textContent = `${Utils.formatNumber(remainingExp)}`; DOMElements.expTooltipWrapper.title = `次の召喚士Lvまで: ${Utils.formatNumber(currentLevelExp)} / ${Utils.formatNumber(expNeeded)} 魂片`; } if (DOMElements.magicStoneValue) DOMElements.magicStoneValue.textContent = Utils.formatNumber(gameState.magicStones); },
        updatePartyInfoSidebar: () => { const listEl = DOMElements.partyInfoList; if (!listEl) return; listEl.innerHTML = ''; if(!gameState.playerParty) return; gameState.playerParty.forEach(p => { const li = document.createElement('li'); li.classList.add('party-member-summary'); li.dataset.characterId = p.uniqueId; if(!p.isAlive()) li.classList.add('dead'); const icon = TraitIcons[p.traits[0]] || '❔'; const hpPercent = Math.max(0, (p.hp / p.maxHp) * 100); let hpBarClass = 'high'; if (hpPercent <= 25) hpBarClass = 'low'; else if (hpPercent <= 60) hpBarClass = 'mid'; li.innerHTML = `<span class="icon">${icon}</span> <span class="name">${p.name} Lv${p.level}</span><div class="party-hp-bar-container"><div class="party-hp-bar ${hpBarClass}" style="width: ${hpPercent}%;"></div></div> <span class="hp">${p.hp}/${p.maxHp}</span>`; /* Click listener added via delegation */ listEl.appendChild(li); }); },
        setSelectedCharacter: (uniqueId) => {
            if (!uniqueId) {
                UIController.clearSelectedCharacterDetails();
                return;
            }
            // No change if already selected
            // if (gameState.selectedCharacterId === uniqueId) return; // Allow re-clicking to refresh details

            gameState.selectedCharacterId = uniqueId;
            UIController.highlightSelectedDetailInList(uniqueId); // Highlight in list/battle area
            UIController.updateSelectedCharacterDetails(); // Update the detail panel
        },
        updateSelectedCharacterDetails: () => {
            const uniqueId = gameState.selectedCharacterId;
            const currentPhase = gameState.currentPhase;
            let targetDetailsPanel = null;

            // Identify the correct detail panel based on the current phase
            switch (currentPhase) {
                case GamePhase.HUB:             targetDetailsPanel = DOMElements.hubDetailsPanel; break;
                case GamePhase.SUMMON_CONTRACT: targetDetailsPanel = DOMElements.summonDetailsPanel; break;
                case GamePhase.PARTY_SELECT:    targetDetailsPanel = DOMElements.partyDetailsPanel; break;
                case GamePhase.BATTLE:          targetDetailsPanel = DOMElements.battleDetailsPanel; break;
                default: // No detail panel on other screens like title, ready, setup, result
                    UIController.clearSelectedCharacterDetails();
                    return;
            }

            if (!targetDetailsPanel || !targetDetailsPanel.container || !targetDetailsPanel.name || !targetDetailsPanel.content || !targetDetailsPanel.placeholder) {
                console.warn("Target detail panel elements not found for phase:", currentPhase);
                UIController.clearSelectedCharacterDetails();
                return;
            }

            // Show the container, hide the placeholder
             if (targetDetailsPanel.container.classList.contains('hidden')) {
                 targetDetailsPanel.container.classList.remove('hidden'); // Ensure battle detail panel is shown when selected
             }
            targetDetailsPanel.placeholder.style.display = 'none';
            targetDetailsPanel.content.innerHTML = ''; // Clear previous content

            if (!uniqueId) { // If no uniqueId, clear and show placeholder
                UIController.clearSelectedCharacterDetails();
                return;
            }

            // --- Find Character Data ---
            let character = null;
            let baseData = null;
            let isPoolOrPartyData = false;
            let sourceLevel = null;
            let sourceSkills = null;
            let sourceBoostedStats = { hp: 0, atk: 0, def: 0 }; // Default boost

            if (currentPhase === GamePhase.BATTLE) {
                // Find live character instance in battle
                character = gameState.playerParty?.find(p => p.uniqueId === uniqueId) || gameState.opponentParty?.find(o => o.uniqueId === uniqueId);
                if (character) baseData = CharacterDatabase[character.baseId];
            } else {
                // Find data based on uniqueId pattern for non-battle screens
                let partyDataEntry = gameState.playerPartyData.find(p => p.uniqueId === uniqueId);
                if (partyDataEntry) { // Found in current party data (Hub, Party Select)
                    baseData = CharacterDatabase[partyDataEntry.baseId];
                    if (baseData) {
                        isPoolOrPartyData = true;
                        sourceLevel = partyDataEntry.level;
                        sourceSkills = partyDataEntry.skills.map(id => SkillDatabase[id]).filter(Boolean);
                        sourceBoostedStats = partyDataEntry.boostedStats || { hp: 0, atk: 0, def: 0 };
                    }
                } else if (uniqueId.startsWith('p-pool-')) { // Found in monster pool (Party Select)
                    const baseId = uniqueId.substring(7);
                    const poolEntry = gameState.playerMonsterPool.find(p => p.baseId === baseId);
                    if (poolEntry) {
                        baseData = CharacterDatabase[baseId];
                        if (baseData) {
                            isPoolOrPartyData = true;
                            sourceLevel = poolEntry.currentLevel;
                            sourceSkills = baseData.skills; // Show base skills for pool view
                            // Pool items don't have individual boosts
                        }
                    }
                } else if (uniqueId.startsWith('s-cand-')) { // Found in summon candidates (Summon Contract)
                    const baseId = uniqueId.substring(7);
                    baseData = CharacterDatabase[baseId];
                    if (baseData) {
                        isPoolOrPartyData = true;
                        sourceLevel = 1; // Candidates are shown as Lv 1
                        sourceSkills = baseData.skills; // Show base skills for candidates
                         // Candidates don't have boosts
                    }
                }

                // If data found, create a temporary Character instance for display
                if (baseData && isPoolOrPartyData) {
                    // Need to handle skills properly - baseData.skills are objects, partyDataEntry.skills are IDs
                    let skillsForInstance = sourceSkills; // Use already resolved skills if available
                    if (!skillsForInstance) {
                        skillsForInstance = baseData.skills; // Fallback to base skills if needed
                    }
                    character = new Character(baseData, 'unknown', sourceLevel, skillsForInstance, uniqueId, AIType.NORMAL, sourceBoostedStats);
                    character.hp = character.maxHp; // Show full HP for non-battle display
                }
            }
            // --- End Find Character Data ---


            if (!character || !baseData) {
                console.warn("Character data not found for ID:", uniqueId, "in phase:", currentPhase);
                UIController.clearSelectedCharacterDetails();
                 targetDetailsPanel.placeholder.textContent = "データが見つかりません";
                 targetDetailsPanel.placeholder.style.display = 'block';
                return;
            }

            // --- Populate Panel ---
            targetDetailsPanel.name.textContent = `${character.name} (Lv${character.level})`;
            targetDetailsPanel.content.innerHTML += `<p class="description">${character.description}</p>`;

            const hpBoostHtml = character.boostedStats.hp > 0 ? `(<span style="color: var(--text-light);">${character.maxHpBase}</span><span class="stat-boost">+${character.boostedStats.hp}</span>)` : '';
            const atkBoostHtml = character.boostedStats.atk > 0 ? `(<span style="color: var(--text-light);">${character.baseAtkBase}</span><span class="stat-boost">+${character.boostedStats.atk}</span>)` : '';
            const defBoostHtml = character.boostedStats.def > 0 ? `(<span style="color: var(--text-light);">${character.baseDefBase}</span><span class="stat-boost">+${character.boostedStats.def}</span>)` : '';

            const hpDisplay = (currentPhase === GamePhase.BATTLE) ? character.hp : character.maxHp; // Show current HP only in battle
            targetDetailsPanel.content.innerHTML += `<div class="detail-section"><h5>ステータス</h5><p>HP:${hpDisplay}/${character.maxHp}${hpBoostHtml} 攻:${character.currentAtk}${atkBoostHtml} 防:${character.currentDef}${defBoostHtml} 速:${character.speed}</p></div>`;

            if (character.traits.length > 0) {
                targetDetailsPanel.content.innerHTML += `<div class="detail-section"><h5>特性</h5><ul class="trait-list">${character.traits.map(t => `<li><span class="trait-name">${TraitIcons[t]||'?'} ${t}:</span> <span class="trait-desc">${TraitDescriptions[t] || '説明なし'}</span></li>`).join('')}</ul></div>`;
            }

            const actualBaseData = CharacterDatabase[character.baseId]; // Use baseId to get base resistances
            const baseResists = actualBaseData?.resistances || {};
            let resHtml = '';
            const attrOrder = [Attribute.PHYSICAL, Attribute.FIRE, Attribute.ICE, Attribute.HOLY, Attribute.DARK];
            attrOrder.forEach(attrName => {
                const val = baseResists[attrName];
                let resClass = '', resText = '';
                if (val === 0) { resClass='res-immune log-immune'; resText='無効'; }
                else if (val !== undefined && val < 1) { resClass='res-strong log-resistance'; resText=`耐性(${val.toFixed(1)}x)`; }
                else if (val !== undefined && val > 1) { resClass='res-weak log-weakness'; resText=`弱点(${val.toFixed(1)}x)`; }
                if(resClass) resHtml += `<span class="${resClass}" style="margin-right: 5px; padding: 1px 3px; border-radius: 3px;">${attrName}${resText ? ': '+resText : ''}</span>`;
            });
            if (resHtml) {
                targetDetailsPanel.content.innerHTML += `<div class="detail-section"><h5>属性相性</h5><p class="resistances-list">${resHtml}</p></div>`;
            }

            if (currentPhase === GamePhase.BATTLE && Object.keys(character.statusEffects).length > 0) {
                 targetDetailsPanel.content.innerHTML += `<div class="detail-section"><h5>状態異常</h5><p class="status-list">${Object.entries(character.statusEffects).map(([type, effect]) => `<span class="status-icon ${`icon-${type.toLowerCase().replace('↓','_down').replace('↑','_up').replace(' ','_')}`.split(' ')[0]}" title="${type}: ${StatusDescriptions[type] || '効果不明'} (${effect.turns === Infinity ? '永続' : effect.turns + 'T 残り'})">${StatusIcons[type] || type.substring(0,1)}${effect.turns < 99 ? effect.turns : ''}</span>`).join(' ')}</p></div>`;
            }

            const skillsSection = document.createElement('div');
            skillsSection.classList.add('detail-section', 'detail-panel-skills');
            let skillTitle = '現在のアビリティ';
            if(currentPhase === GamePhase.SUMMON_CONTRACT) skillTitle = '習得候補アビリティ';
            else if(currentPhase === GamePhase.PARTY_SELECT && uniqueId.startsWith('p-pool-')) skillTitle = '初期アビリティ';
            skillsSection.innerHTML = `<h5>${skillTitle}</h5>`;

            const skillListUl = document.createElement('ul');
            const skillsToDisplay = character.skills || [];
            if (skillsToDisplay.length > 0) {
                skillsToDisplay.forEach((skill, index) => {
                    if (!skill || !skill.id) return;
                    // Highlight next skill only in battle for living characters
                    const isNext = currentPhase === GamePhase.BATTLE && !isPoolOrPartyData && character.isAlive() && (index === character.nextSkillIndex % skillsToDisplay.length);
                    const li = document.createElement('li');

                    let skillNameHtml = `<span class="skill-name ${isNext ? 'next-skill' : ''}">${isNext?'▶ ':''}${skill.name}</span>`;
                    let skillInfoHtml = `<div class="skill-info">`;
                    let targetText = '';
                    switch(skill.target){ case'enemy_single':targetText='敵単体';break; case'ally_single':targetText='味方単体';break; case'self':targetText='自身';break; case'enemy_all':targetText='敵全体';break; case'ally_all':targetText='味方単体';break; default:targetText='-'; } // Fixed ally_all typo
                    skillInfoHtml += `<span>対象: ${targetText}</span>`;
                    if (skill.power) skillInfoHtml += `<span>威力: ${skill.power}</span>`;
                    if (skill.attribute) skillInfoHtml += `<span>属性: ${skill.attribute}</span>`;
                    if (skill.drainRate) skillInfoHtml += `<span>吸収率: ${skill.drainRate*100}%</span>`;
                    if (skill.effect && skill.effect !== 'remove_poison') skillInfoHtml += `<span>効果: ${skill.effect} (${skill.chance ? skill.chance*100+'%' : '100%'}, ${skill.turns || '永続'}T)</span>`;
                    else if (skill.effect === 'remove_poison') skillInfoHtml += `<span>効果: 毒解除</span>`;
                    if (skill.hits) skillInfoHtml += `<span>ヒット数: ${skill.hits}</span>`;

                    const tags = skill.tags ? skill.tags.map(tag => `<span class="skill-tags tag-${tag.replace('_','-')}">${tag.replace('_','-')}</span>`).join('') : '';
                    skillInfoHtml += tags;
                    skillInfoHtml += `</div>`; // End skill-info

                    const skillDesc = SkillDescriptions[skill.id];
                    if (skillDesc) {
                        skillInfoHtml += `<p style="font-size: 0.9em; margin-top: 3px; color: var(--text-mid);">${skillDesc}</p>`;
                    }
                    li.innerHTML = skillNameHtml + skillInfoHtml;
                    skillListUl.appendChild(li);
                });
            } else {
                skillListUl.innerHTML = '<li>なし</li>';
            }
            skillsSection.appendChild(skillListUl);
            targetDetailsPanel.content.appendChild(skillsSection);

            // Scroll detail panel content to top
            targetDetailsPanel.content.scrollTop = 0;
            // --- End Populate Panel ---
        },
        clearSelectedCharacterDetails: () => {
            gameState.selectedCharacterId = null;
            const panels = [
                 DOMElements.hubDetailsPanel,
                 DOMElements.summonDetailsPanel,
                 DOMElements.partyDetailsPanel,
                 DOMElements.battleDetailsPanel
             ];

            panels.forEach(panel => {
                if(panel && panel.container && panel.name && panel.content && panel.placeholder) {
                    panel.name.textContent = 'キャラクター詳細'; // Reset title
                    panel.content.innerHTML = ''; // Clear content
                    let placeholderText = '対象を選択してください';
                     if(panel === DOMElements.hubDetailsPanel) placeholderText = '詳細を確認したいパーティメンバーをクリック';
                     else if(panel === DOMElements.summonDetailsPanel) placeholderText = '詳細を確認したい契約候補をクリック';
                     else if(panel === DOMElements.partyDetailsPanel) placeholderText = '詳細を確認したい使い魔をクリック';
                     else if(panel === DOMElements.battleDetailsPanel) placeholderText = 'キャラクターをクリックして詳細表示';
                    panel.placeholder.textContent = placeholderText; // Set appropriate placeholder
                    panel.placeholder.style.display = 'block'; // Show placeholder
                    // For battle panel, ensure it's hidden if nothing is selected
                    if(panel === DOMElements.battleDetailsPanel) {
                        panel.container.classList.add('hidden');
                    }
                } else {
                     // console.warn("Panel elements missing during clear:", panel);
                }
            });

            // Remove highlights from lists/cards
            UIController.highlightSelectedDetailInList(null);
        },
        showRewardModal: (rewards) => { const optionsDiv = DOMElements.rewardOptionsDiv; const detailsList = DOMElements.nextEnemyDetailsList; if (!optionsDiv || !detailsList) return; optionsDiv.innerHTML = ''; detailsList.innerHTML = ''; gameState.selectedReward = null; DOMElements.confirmRewardButton.disabled = true; const nextWaveEnemiesPreview = rewardSystem.previewNextWaveEnemies(); DOMElements.nextFloorInfoP.innerHTML = `主な出現魔物: ${nextWaveEnemiesPreview.names.join(', ')} など (約${nextWaveEnemiesPreview.countRange}体)`; nextWaveEnemiesPreview.detailedEnemies.forEach(enemyData => { const card = document.createElement('div'); card.classList.add('next-enemy-card'); const traitsHtml = enemyData.traits?.map(t => `<span title="${TraitDescriptions[t]||''}">${TraitIcons[t]||'?'}</span>`).join(' ') || 'なし'; const skillsHtml = enemyData.skills?.slice(0, 2).map(s => `<li>${s.name}</li>`).join('') || '<li>不明</li>'; card.innerHTML = `<h5>${enemyData.name}</h5><p>HP:${enemyData.hp} 攻:${enemyData.atk} 防:${enemyData.def} 速:${enemyData.speed}</p><p class="traits">特性: ${traitsHtml}</p><p class="skills">主なスキル:<ul>${skillsHtml}</ul></p>`; detailsList.appendChild(card); }); rewards.forEach((reward, index) => { const card = document.createElement('div'); card.classList.add('reward-card'); card.dataset.rewardIndex = index; let title = '', desc = '', icon = '❓', details = ''; const targetName = reward.targetMonster?.name || ''; switch(reward.type) { case 'new_skill': const newSkill = reward.skill; title = `新アビリティ`; desc = `[${targetName}] が<br>《${newSkill.name}》を習得`; icon = '💡'; details = `${newSkill.attribute ? '['+newSkill.attribute+']' : ''} 威力:${newSkill.power||'-'} 効果:${newSkill.effect||'-'}`; break; case 'upgrade_skill': const upSkill = reward.skill; title = `アビリティ強化`; desc = `[${targetName}] の<br>《${upSkill.name.replace('+','')}》を強化`; icon = '⭐'; details = `威力 ${upSkill.power} → ${Math.round((upSkill.power || 0) * 1.2 + 5)}`; break; case 'status_boost': const statJP = {'hp':'最大HP','atk':'攻撃力','def':'防御力'}; title = `ステータス強化`; desc = `[${targetName}] の<br>${statJP[reward.stat]} を上昇`; icon = {'hp':'❤️','atk':'⚔️','def':'🛡️'}[reward.stat]; let boostVal = 0; if (reward.stat === 'hp') boostVal = Math.round(reward.targetMonster.maxHpBase * 0.15 + 10); else if (reward.stat === 'atk') boostVal = Math.round(reward.targetMonster.baseAtkBase * 0.12 + 3); else if (reward.stat === 'def') boostVal = Math.round(reward.targetMonster.baseDefBase * 0.12 + 3); details = `${statJP[reward.stat]} +${boostVal}`; break; case 'level_up': title = `レベルアップ`; desc = `[${targetName}] の<br>レベルが上昇！`; icon = '🌟'; details = `Lv ${reward.targetMonster.level} → ${reward.targetMonster.level + 1}`; break; case 'temp_buff': let buffName = ''; if (reward.buffType === StatusEffect.TEMP_ATK_UP) buffName = '攻撃力'; else if (reward.buffType === StatusEffect.TEMP_FIRE_UP) buffName = '炎属性攻撃'; title = `一時強化`; desc = `次の ${reward.duration} 階層の間、<br>味方全体の ${buffName} UP`; icon = '⚡'; details = `効果は戦闘開始時に発動`; break; case 'exp_gain': title = `魂片獲得`; desc = `召喚士経験値として<br>${Utils.formatNumber(reward.amount)} 魂片を獲得`; icon = '✨'; details = `即座に召喚士レベルに反映`; break; case 'stone_gain': title = `魔石獲得`; desc = `召喚契約に使用できる<br><span class="magic-stone-value">${Utils.formatNumber(reward.amount)} 魔石</span> を獲得`; icon = LogIcons.stone; details = `貴重なリソース`; break; default: title = '謎の報酬'; desc = '何かが起こるかもしれない...'; icon = '❓'; } card.innerHTML = `<h4>${icon} ${title}</h4><p>${desc}</p><div class="reward-details">${details}</div>`; card.addEventListener('click', () => { document.querySelectorAll('#reward-options .reward-card.selected').forEach(el => el.classList.remove('selected')); card.classList.add('selected'); gameState.selectedReward = reward; DOMElements.confirmRewardButton.disabled = false; }); optionsDiv.appendChild(card); }); UIController.switchScreen(GamePhase.REWARD_SELECT); },
        hideRewardModal: () => { DOMElements.rewardModal.classList.remove('active'); setTimeout(() => DOMElements.rewardModal.style.display = 'none', 150); },
        setupResultScreen: (isRetire = false) => { const titleEl = DOMElements.resultTitle; titleEl.textContent = isRetire ? "魔塔から帰還" : "挑戦失敗..."; titleEl.className = isRetire ? 'win' : 'lose'; const finalFloor = gameState.currentWave - 1; const expGainedInRun = gameState.playerTotalExpInRun; const stonesGainedInRun = gameState.playerTotalStonesInRun; const expBonusRate = isRetire ? RETIRE_EXP_RATE : GAMEOVER_EXP_RATE; const stoneBonusRate = isRetire ? RETIRE_STONE_RATE : GAMEOVER_STONE_RATE; const bonusExp = Math.floor(expGainedInRun * expBonusRate); const bonusStones = Math.floor(stonesGainedInRun * stoneBonusRate); DOMElements.resultFloor.textContent = `到達階層: ${finalFloor}`; DOMElements.resultExp.innerHTML = `獲得した魂片 (EXP): <span>${Utils.formatNumber(expGainedInRun)}</span> (${isRetire ? '帰還' : '全滅'}ボーナス: <span style="color: ${bonusExp > 0 ? 'var(--accent-green)' : 'var(--text-mid)'};">${Utils.formatNumber(bonusExp)}</span>)`; DOMElements.resultStones.innerHTML = `獲得した魔石: <span>${Utils.formatNumber(stonesGainedInRun)}</span> (${isRetire ? '帰還' : '全滅'}ボーナス: <span style="color: ${bonusStones > 0 ? 'var(--accent-green)' : 'var(--text-mid)'};">${Utils.formatNumber(bonusStones)}</span>) <span title="魔石">💎</span>`; DOMElements.resultLevel.querySelector('span').textContent = gameState.playerAccountLevel; let expForCurrentLevelTotal = 0; for(let i = 0; i < gameState.playerAccountLevel; i++) { expForCurrentLevelTotal += Utils.getExpForNextAccountLevel(i); } const expNeeded = Utils.getExpForNextAccountLevel(gameState.playerAccountLevel); const currentLevelExp = Math.max(0, gameState.playerAccountTotalExp - expForCurrentLevelTotal); const remainingExp = Math.max(0, expNeeded - currentLevelExp); DOMElements.resultNextExp.querySelector('span').textContent = `${Utils.formatNumber(remainingExp)}`; DOMElements.resultNextExp.title = `次の召喚士Lvまで: ${Utils.formatNumber(currentLevelExp)} / ${Utils.formatNumber(expNeeded)} 魂片`; },
        showTooltip: (target) => { if (target instanceof Character) UIController.showTooltipForCharacter(target); else if (target instanceof HTMLElement && target.title) UIController.showTooltipForElement(target); },
        showTooltipForCharacter: (character) => { clearTimeout(UIController.tooltipTimeout); UIController.hideTooltip(); const tooltip = DOMElements.tooltipElement; if (!tooltip || !character.element || !character.element.isConnected) return; UIController.tooltipTimeout = setTimeout(() => { let html = `<b>${character.name} (Lv${character.level})</b><br>`; html += `HP: ${character.hp}/${character.maxHp}${character.boostedStats.hp > 0 ? `(${character.maxHpBase}<span class="stat-boost">+${character.boostedStats.hp}</span>)`:''}<br>`; html += `攻:${character.currentAtk}(${character.baseAtkBase}${character.boostedStats.atk > 0 ? `<span class="stat-boost">+${character.boostedStats.atk}</span>`:''}) 防:${character.currentDef}(${character.baseDefBase}${character.boostedStats.def > 0 ? `<span class="stat-boost">+${character.boostedStats.def}</span>`:''}) 速:${character.speed}<br>`; if (character.traits.length > 0) { html += `特性: ${character.traits.map(t => `<span title="${TraitDescriptions[t]||''}">${TraitIcons[t]||'?'} ${t}</span>`).join(', ')}<br>`; } if (Object.keys(character.statusEffects).length > 0) { html += `状態: ${Object.entries(character.statusEffects).map(([type, effect]) => `<span class="${`icon-${type.toLowerCase().replace('↓','_down').replace('↑','_up').replace(' ','_')}`.split(' ')[0]}" title="${StatusDescriptions[type]||''}">${StatusIcons[type]||'?'}${effect.turns<99?effect.turns:''}</span>`).join(' ')}<br>`; } const nextSkill = character.peekNextSkill(); html += `次の行動: ${nextSkill.name}`; tooltip.innerHTML = html; tooltip.style.display = 'block'; const targetRect = character.element.getBoundingClientRect(); const tooltipRect = tooltip.getBoundingClientRect(); let top = targetRect.top - tooltipRect.height - 8; let left = targetRect.left + (targetRect.width / 2) - (tooltipRect.width / 2); if (top < 0) top = targetRect.bottom + 8; if (left < 0) left = 5; if (left + tooltipRect.width > window.innerWidth) left = window.innerWidth - tooltipRect.width - 5; tooltip.style.top = `${top + window.scrollY}px`; tooltip.style.left = `${left + window.scrollX}px`; }, 400); },
        showTooltipForElement: (element) => { clearTimeout(UIController.tooltipTimeout); UIController.hideTooltip(); const tooltip = DOMElements.tooltipElement; if (!tooltip || !element || !element.isConnected || !element.title) return; UIController.tooltipTimeout = setTimeout(() => { tooltip.innerHTML = element.title.replace(/\n/g, '<br>'); tooltip.style.display = 'block'; const targetRect = element.getBoundingClientRect(); const tooltipRect = tooltip.getBoundingClientRect(); let top = targetRect.bottom + 8; let left = targetRect.left + (targetRect.width / 2) - (tooltipRect.width / 2); if (top + tooltipRect.height > window.innerHeight) top = targetRect.top - tooltipRect.height - 8; if (left < 0) left = 5; if (left + tooltipRect.width > window.innerWidth) left = window.innerWidth - tooltipRect.width - 5; tooltip.style.top = `${top + window.scrollY}px`; tooltip.style.left = `${left + window.scrollX}px`; }, 300); },
        hideTooltip: () => { clearTimeout(UIController.tooltipTimeout); if (DOMElements.tooltipElement) { DOMElements.tooltipElement.style.display = 'none'; } },
        displayFlavorText: () => {
            const phase = gameState.currentPhase;
            const showColumnFlavor = [GamePhase.HUB, GamePhase.SUMMON_CONTRACT, GamePhase.PARTY_SELECT, GamePhase.BATTLE].includes(phase);

            if (showColumnFlavor && DOMElements.column4FlavorArea && DOMElements.column4FlavorTitle && DOMElements.column4FlavorText) {
                 const flavorList = FlavorTexts[phase] || FlavorTexts.default;
                 let newText = Utils.shuffleArray([...flavorList])[0]; let attempts = 0;
                 while (newText === DOMElements.column4FlavorText.textContent && flavorList.length > 1 && attempts < 5) { newText = Utils.shuffleArray([...flavorList])[0]; attempts++; }

                 DOMElements.column4FlavorText.textContent = newText;
                 switch(phase) {
                     case GamePhase.HUB: DOMElements.column4FlavorTitle.textContent = "拠点の噂"; break;
                     case GamePhase.SUMMON_CONTRACT: DOMElements.column4FlavorTitle.textContent = "契約の知識"; break;
                     case GamePhase.PARTY_SELECT: DOMElements.column4FlavorTitle.textContent = "編成の心得"; break;
                     case GamePhase.BATTLE: DOMElements.column4FlavorTitle.textContent = "戦場の囁き"; break;
                     default: DOMElements.column4FlavorTitle.textContent = "塔の声";
                 }
                 DOMElements.column4FlavorArea.classList.add('active');
             } else if (DOMElements.column4FlavorArea) {
                 DOMElements.column4FlavorArea.classList.remove('active');
             }
        }
    }; // UIController End

    // --- Reward System (previewNextWaveEnemies 修正) ---
    const rewardSystem = {
        generateRewards: () => { const rewards = []; const livingParty = gameState.playerParty.filter(p => p.isAlive()); if (livingParty.length === 0) return []; const possibleRewards = []; livingParty.forEach(p => { if (p.skills.length < MAX_SKILLS_PER_MONSTER) { const currentSkillIds = p.skills.map(s => s.id); const potentialNewSkills = Object.values(SkillDatabase).filter(skill => !currentSkillIds.includes(skill.id) && (skill.power < 50 || !skill.power)).map(skill => ({ skillId: skill.id, skill: skill })); if(potentialNewSkills.length > 0) { const randomSkill = Utils.shuffleArray(potentialNewSkills)[0]; possibleRewards.push({ type: 'new_skill', targetMonster: p, skill: randomSkill.skill, skillId: randomSkill.skillId }); } } }); livingParty.forEach(p => { p.skills.forEach((skill, index) => { if (skill.power > 0 && !skill.name.endsWith('+')) { possibleRewards.push({ type: 'upgrade_skill', targetMonster: p, skill: skill, skillIndex: index }); } }); }); livingParty.forEach(p => { possibleRewards.push({ type: 'status_boost', targetMonster: p, stat: 'hp' }); possibleRewards.push({ type: 'status_boost', targetMonster: p, stat: 'atk' }); possibleRewards.push({ type: 'status_boost', targetMonster: p, stat: 'def' }); }); livingParty.forEach(p => { possibleRewards.push({ type: 'level_up', targetMonster: p }); }); possibleRewards.push({ type: 'temp_buff', buffType: StatusEffect.TEMP_ATK_UP, duration: 1 }); possibleRewards.push({ type: 'temp_buff', buffType: StatusEffect.TEMP_FIRE_UP, duration: 1 }); const expGainMultiplier = account.getAccountLevelBonus('expGainMultiplier'); const expRewardAmount = Math.floor(Utils.getRandomInt(20, 50) * Math.pow(gameState.currentWave, 0.7) * expGainMultiplier); possibleRewards.push({ type: 'exp_gain', amount: expRewardAmount }); const stoneGainMultiplier = account.getAccountLevelBonus('stoneGainMultiplier'); const stoneRewardAmount = Math.floor(Utils.getRandomInt(5, 15) * Math.pow(gameState.currentWave, 0.5) * stoneGainMultiplier); possibleRewards.push({ type: 'stone_gain', amount: stoneRewardAmount }); const numRewardOptions = account.getAccountLevelBonus('rewardOptions'); const shuffledRewards = Utils.shuffleArray(possibleRewards); for(let i = 0; i < numRewardOptions && i < shuffledRewards.length; i++) { rewards.push(shuffledRewards[i]); } return rewards; },
        applyReward: (reward) => { if (!reward) return; let target = null; if (reward.targetMonster) { target = gameState.playerParty.find(p => p.uniqueId === reward.targetMonster.uniqueId); if (!target) { console.error("Reward target monster not found:", reward.targetMonster.uniqueId); return; } } switch(reward.type) { case 'new_skill': if(target) target.addSkill(reward.skillId); break; case 'upgrade_skill': if(target) target.upgradeSkill(reward.skillIndex); break; case 'status_boost': if(target) target.boostStatus(reward.stat); break; case 'level_up': if(target) { target.level++; const baseData = CharacterDatabase[target.baseId]; const levelMultiplier = 1 + (target.level - 1) * 0.08; const oldMaxHp = target.maxHp; target.maxHpBase = Math.round(baseData.hp * levelMultiplier); target.baseAtkBase = Math.round(baseData.atk * levelMultiplier); target.baseDefBase = Math.round(baseData.def * levelMultiplier); target.recalculateStats(); target.hp += (target.maxHp - oldMaxHp); target.hp = Math.min(target.maxHp, target.hp); UIController.log(`${target.name} のレベルが ${target.level} に上がった！`, 'log-win', { icon: LogIcons.levelup }); } break; case 'temp_buff': gameState.temporaryBuffs = gameState.temporaryBuffs || {}; gameState.temporaryBuffs[reward.buffType] = (gameState.temporaryBuffs[reward.buffType] || 0) + reward.duration; let buffName = Object.keys(StatusEffect).find(key => StatusEffect[key] === reward.buffType) || reward.buffType; UIController.log(`一時効果: 次の ${reward.duration} 階層で ${buffName} が上昇！`, 'log-win', { icon: '⚡' }); break; case 'exp_gain': account.addExperience(reward.amount); UIController.log(`魂片を ${Utils.formatNumber(reward.amount)} 獲得！`, 'log-win', { icon: '✨'}); break; case 'stone_gain': // ここでは run total に加算せず、直接所持数に加算
            account.addMagicStones(reward.amount); // 直接アカウントの魔石に加算
            UIController.log(`魔石を ${Utils.formatNumber(reward.amount)} 獲得！ (所持魔石: ${Utils.formatNumber(gameState.magicStones)})`, 'log-win', { icon: LogIcons.stone}); break; } gameFlow.updatePlayerPartyData(); UIController.updatePartyInfoSidebar(); UIController.updateSelectedCharacterDetails(); },
        generateAndShowRewards: () => { const rewards = rewardSystem.generateRewards(); if(rewards.length > 0) { UIController.showRewardModal(rewards); } else { UIController.log("獲得できる報酬がありませんでした。", "log-info"); setTimeout(() => { gameFlow.prepareNextWaveAfterReward(); }, 1000); } },
        previewNextWaveEnemies: () => { const nextWave = gameState.currentWave + 1; const availableEnemies = Object.values(CharacterDatabase).filter(c => !c.id.startsWith('p_')); // 使用可能な敵リスト
            let numEnemiesMin = Math.max(1, Math.min(8, nextWave -1)); let numEnemiesMax = Math.min(8, nextWave + 2); if (nextWave <= 3) { numEnemiesMin = Math.max(1, nextWave -1); numEnemiesMax = nextWave; } const enemyCount = Utils.getRandomInt(numEnemiesMin, numEnemiesMax); const countRange = numEnemiesMin === numEnemiesMax ? `${enemyCount}` : `${numEnemiesMin}~${numEnemiesMax}`; const baseLevel = Math.max(1, Math.floor(nextWave * 1.0 + gameState.playerPartyLevel * 0.05));
            // 適切な強さの敵候補をフィルタリング
            const enemyCandidates = availableEnemies.filter(enemy => { const appropriateness = (enemy.hp / 4 + enemy.atk + enemy.def) / 3; const targetStrength = baseLevel * 4; return appropriateness > targetStrength * 0.4 && appropriateness < targetStrength * 2.0; });
            const finalCandidates = enemyCandidates.length > 0 ? enemyCandidates : availableEnemies; // 候補がいなければ全敵から選ぶ
            let previewEnemies = []; for(let i=0; i< enemyCount; i++){ const candidate = Utils.shuffleArray([...finalCandidates])[0]; if (candidate) previewEnemies.push(candidate); else console.warn("Could not find suitable enemy candidate for preview"); } const uniqueNames = [...new Set(previewEnemies.map(e => e.name))]; const detailedEnemies = Utils.shuffleArray(uniqueNames).slice(0, 3).map(name => previewEnemies.find(e => e.name === name)).filter(Boolean); return { names: uniqueNames, countRange: countRange, detailedEnemies: detailedEnemies.map(e => ({ name: e.name, hp: Math.round(e.hp * (1 + (baseLevel - 1) * 0.08)), atk: Math.round(e.atk * (1 + (baseLevel - 1) * 0.08)), def: Math.round(e.def * (1 + (baseLevel - 1) * 0.08)), speed: Math.round(e.speed * (1 + (baseLevel - 1) * 0.04)), traits: e.traits, skills: e.skills })) }; }
    };

    // --- Game Logic Functions ---
    function generateOpponentParty(wave, difficulty) { const party = []; const availableEnemies = Object.values(CharacterDatabase).filter(c => !c.id.startsWith('p_')); let numEnemiesMin = Math.max(1, Math.min(8, wave - 1)); let numEnemiesMax = Math.min(8, wave + 2); if (wave <= 3) { numEnemiesMin = Math.max(1, wave -1); numEnemiesMax = wave; } const numEnemies = Utils.getRandomInt(numEnemiesMin, numEnemiesMax); const baseLevel = Math.max(1, Math.floor(wave * 1.0 + gameState.playerPartyLevel * 0.05)); const aiTypes = [AIType.NORMAL, AIType.LOW_HP_FOCUS, AIType.HIGH_ATK_FOCUS, AIType.HEALER_HUNTER]; const enemyCandidates = availableEnemies.filter(enemy => { const appropriateness = (enemy.hp / 4 + enemy.atk + enemy.def) / 3; const targetStrength = baseLevel * 4; return appropriateness > targetStrength * 0.4 && appropriateness < targetStrength * 2.0; }); const finalCandidates = enemyCandidates.length > 0 ? enemyCandidates : availableEnemies; for (let i = 0; i < numEnemies; i++) { const enemyData = Utils.shuffleArray([...finalCandidates])[0]; if (!enemyData) { console.warn("Could not find suitable enemy data to generate opponent."); continue; } const enemyLevel = Math.max(1, baseLevel + Utils.getRandomInt(-1, 1)); const enemyAi = Utils.shuffleArray(aiTypes)[0]; party.push(new Character(enemyData, 'opponent', enemyLevel, null, null, enemyAi)); } return party; }

     // --- Game Flow Control (イベントリスナー修正) ---
     const gameFlow = {
        initialize: () => {
            account.loadPermanentData(); UIController.setupTitleScreen(); UIController.switchScreen(GamePhase.TITLE);
            // --- Button Listeners ---
            DOMElements.startGameButton?.addEventListener('click', gameFlow.startNewGame); DOMElements.continueGameButton?.addEventListener('click', gameFlow.continueGame);
            DOMElements.hubPartyButton?.addEventListener('click', gameFlow.enterPartySelection); DOMElements.hubSummonButton?.addEventListener('click', gameFlow.enterSummonContract); DOMElements.hubChallengeButton?.addEventListener('click', gameFlow.enterReadyScreen);
            DOMElements.backToHubButton?.addEventListener('click', gameFlow.returnToHub); DOMElements.confirmPartyButton?.addEventListener('click', party編成.confirmParty);
            DOMElements.startFirstWaveButton?.addEventListener('click', gameFlow.startFirstWave);
            DOMElements.backToHubFromReadyButton?.addEventListener('click', gameFlow.returnToHub);
            DOMElements.startBattleButton?.addEventListener('click', () => { if(gameState.currentPhase === GamePhase.SETUP && gameState.battleManager) gameState.battleManager.startBattlePhase(); });
            DOMElements.retryButton?.addEventListener('click', gameFlow.returnToHub); DOMElements.backToTitleButton?.addEventListener('click', () => gameFlow.restartGame(true));
            DOMElements.confirmRewardButton?.addEventListener('click', gameFlow.confirmRewardAndProceed); DOMElements.retireButton?.addEventListener('click', gameFlow.retireRun);
            DOMElements.closeRewardButton?.addEventListener('click', UIController.hideRewardModal);
            DOMElements.column4FlavorArea?.addEventListener('click', UIController.displayFlavorText);

            // --- Delegated Event Listeners ---
            const setupDelegatedListeners = (parentElement, selector, eventType, handler) => { if (parentElement) { parentElement.addEventListener(eventType, (e) => { const targetElement = e.target.closest(selector); if (targetElement) { handler(e, targetElement); } }); } };

            // Tooltips
            setupDelegatedListeners(DOMElements.gameWrapper, '[title]', 'mouseenter', (e, target) => UIController.showTooltip(target));
            setupDelegatedListeners(DOMElements.gameWrapper, '[title]', 'mouseleave', (e, target) => UIController.hideTooltip());
            setupDelegatedListeners(DOMElements.gameWrapper, '.trait-icon, .status-icon', 'mouseenter', (e, target) => UIController.showTooltip(target));
            setupDelegatedListeners(DOMElements.gameWrapper, '.trait-icon, .status-icon', 'mouseleave', (e, target) => UIController.hideTooltip());

            // Character Detail Selection
            const listItemClickHandler = (e, target) => {
                 // Only trigger if the click wasn't on a button inside the list item
                 if (!e.target.closest('button')) {
                     // Use data-unique-id primarily, fallback to id for battle cards
                     const uniqueId = target.dataset.uniqueId || target.id;
                     if (uniqueId) {
                         UIController.setSelectedCharacter(uniqueId);
                     } else {
                         console.warn("Clicked element has no data-unique-id or id:", target);
                     }
                 }
             };
            // Lists in Hub, Summon, Party
            setupDelegatedListeners(DOMElements.hubPartyList, 'li', 'click', listItemClickHandler);
            setupDelegatedListeners(DOMElements.summonList, '.summon-list-item', 'click', listItemClickHandler);
            setupDelegatedListeners(DOMElements.monsterPoolListContainer, '.monster-list-item', 'click', listItemClickHandler);
            setupDelegatedListeners(DOMElements.currentPartyListContainer, '.monster-list-item', 'click', listItemClickHandler);

            // Battle Area Cards
            setupDelegatedListeners(DOMElements.playerPartyArea, '.character-card', 'click', listItemClickHandler);
            setupDelegatedListeners(DOMElements.opponentPartyArea, '.character-card', 'click', listItemClickHandler);

             // Party Info Sidebar click in Battle Screen
            setupDelegatedListeners(DOMElements.partyInfo, '.party-member-summary', 'click', (e, target) => {
                 const uniqueId = target.dataset.characterId; // Use specific data attribute
                 if (uniqueId) {
                    UIController.setSelectedCharacter(uniqueId);
                 } else {
                    console.warn("Clicked party summary has no data-character-id:", target);
                 }
            });

            // --- Specific Action Listeners (using delegation for dynamically added elements) ---
            // Summon Button in Summon Screen
            setupDelegatedListeners(DOMElements.summonList, 'button.summon-btn', 'click', (e, target) => {
                const monsterId = target.dataset.monsterId;
                if (monsterId) {
                    summonContract.attemptUnlock(monsterId);
                } else {
                     console.warn("Summon button missing data-monster-id:", target);
                }
            });

            // Add/Remove Buttons in Party Screen are handled within renderPartySelection's loop by adding direct listeners,
            // as they need to prevent event propagation which is easier with direct listeners.

            // Initial UI Setup
            UIController.updateGameInfo();
            UIController.clearSelectedCharacterDetails(); // Start with no character selected
            console.log("Game Initialized and listeners set up.");
        },
        startNewGame: () => {
            Utils.deleteSaveData();
            gameState.currentWave = 1;
            gameState.playerTotalExpInRun = 0;
            gameState.playerTotalStonesInRun = 0;
            gameState.isGameOver = false;
            gameState.isBattleEnded = false;
            gameState.temporaryBuffs = {};
            gameState.playerParty = [];
            gameState.opponentParty = [];
            gameState.battleManager = null;
            gameState.summonCandidates = [];
            partyMemberCounter = 0; // Reset unique ID counter for party members

            account.loadPermanentData(); // Load levels, stones, unlocks etc.
            party編成.resetPool(); // Generate pool based on unlocks and account level

            // Create initial party data (no instances yet)
            gameState.playerPartyData = [];
            const initialPartyIds = INITIAL_UNLOCKED.slice(0, PLAYER_PARTY_SIZE);
            initialPartyIds.forEach(baseId => {
                const baseData = CharacterDatabase[baseId];
                const poolMember = gameState.playerMonsterPool.find(p => p.baseId === baseId);
                const level = poolMember ? poolMember.currentLevel : (1 + account.getAccountLevelBonus('initialMonsterLevel'));
                if (baseData) {
                    const initialSkillIds = (baseData.skills || []).map(s => s.id).filter(Boolean);
                    gameState.playerPartyData.push({
                        baseId: baseId,
                        level: level,
                        skills: initialSkillIds, // Use skill IDs
                        uniqueId: `p-uuid-${partyMemberCounter++}`, // Assign unique ID here
                        boostedStats: { hp: 0, atk: 0, def: 0 }
                    });
                } else {
                    console.warn(`Initial monster data not found for ID: ${baseId}`);
                }
            });

            if (gameState.playerPartyData.length === PLAYER_PARTY_SIZE) {
                 gameState.playerPartyLevel = Math.max(1, Math.floor(gameState.playerPartyData.reduce((sum, p) => sum + p.level, 0) / PLAYER_PARTY_SIZE));
                 console.log("Initial party created:", gameState.playerPartyData);
            } else {
                 gameState.playerPartyLevel = 1;
                 console.warn("Could not create full initial party.");
            }

            gameFlow.returnToHub(); // Go to Hub screen after setup
        },
        continueGame: () => {
            if (Utils.loadGame()) {
                UIController.updateGameInfo();
                if (gameState.playerPartyData.length === PLAYER_PARTY_SIZE) {
                    gameState.playerPartyLevel = Math.max(1, Math.floor(gameState.playerPartyData.reduce((sum, p) => sum + p.level, 0) / PLAYER_PARTY_SIZE));
                    // Recreate instances for battle
                    try {
                        // Note: loadGame already maps skill IDs to skill objects
                        gameState.playerParty = gameState.playerPartyData.map(pData => {
                            const baseData = CharacterDatabase[pData.baseId];
                            if (!baseData) throw new Error(`Base data not found for ${pData.baseId}`);
                            const skills = pData.skills; // Skills should be objects from loadGame
                            const boostedStats = pData.boostedStats || { hp: 0, atk: 0, def: 0 };
                            return new Character(baseData, 'player', pData.level, skills, pData.uniqueId, AIType.NORMAL, boostedStats);
                        });
                         gameState.opponentParty = generateOpponentParty(gameState.currentWave, gameState.difficulty);
                         gameFlow.enterSetupPhase(); // Go to setup phase for the loaded wave
                         UIController.log("中断したところから再開しました。", "log-system");
                    } catch (error) {
                        console.error("Error recreating party instances from saved data:", error);
                        alert("セーブデータからパーティを復元できませんでした。新しくゲームを開始します。");
                        Utils.deleteSaveData();
                        DOMElements.continueGameButton?.classList.add('hidden');
                        gameFlow.startNewGame();
                    }
                } else {
                    console.warn("Loaded game has incomplete party data. Returning to Hub.");
                    gameFlow.returnToHub(); // If party is incomplete, go back to hub
                }
            } else {
                alert("セーブデータの読み込みに失敗しました。新しくゲームを開始します。");
                DOMElements.continueGameButton?.classList.add('hidden');
                gameFlow.startNewGame();
            }
        },
        returnToHub: () => {
             // Ensure playerParty instances are cleared when returning to hub
             gameState.playerParty = [];
             gameState.battleManager = null;
             gameState.isBattleEnded = false; // Reset battle end flag

             party編成.resetPool(); // Reset/update pool based on current unlocks and party data levels
             UIController.switchScreen(GamePhase.HUB); // Handles UI update including detail panel clearing
             UIController.updateGameInfo();
             gameState.selectedReward = null;
             gameState.isGameOver = false;
             // UIController.clearSelectedCharacterDetails(); // Called within switchScreen
          },
        enterPartySelection: () => {
            party編成.initialize(); // Resets pool and renders lists
            UIController.switchScreen(GamePhase.PARTY_SELECT); // Handles UI switching and detail panel clearing
            UIController.updateGameInfo();
        },
        enterSummonContract: () => {
            UIController.switchScreen(GamePhase.SUMMON_CONTRACT); // Handles UI switching, rendering, and detail panel clearing
            UIController.updateGameInfo();
        },
        enterReadyScreen: () => {
             if (!gameState.playerPartyData || gameState.playerPartyData.length !== PLAYER_PARTY_SIZE) {
                 UIController.log("パーティ編成が完了していません！", "log-miss", {icon: '⚠️'});
                 return;
             }
             // Create instances ONLY for the ready screen display, not for battle yet
             try {
                 // Temporarily create instances just for display on ready screen if needed,
                 // but playerPartyData is sufficient for the current setupReadyScreen.
                 // gameState.playerParty = gameState.playerPartyData.map(pData => { /* ... instance creation ... */ });
                 UIController.setupReadyScreen(); // Uses playerPartyData
                 UIController.switchScreen(GamePhase.READY_TO_START);
                 UIController.updateGameInfo();
             } catch (error) {
                 console.error("Error preparing ready screen:", error);
                 alert("出撃準備画面の表示に失敗しました。");
             }
        },
        startFirstWave: () => {
             UIController.log("冒険開始！最初の試練に挑む...", 'log-flavor', {icon: LogIcons.flavor});
             gameState.currentWave = 1;
             gameState.playerTotalExpInRun = 0;
             gameState.playerTotalStonesInRun = 0;
             // Instances are created in enterSetupPhase
             gameState.opponentParty = generateOpponentParty(gameState.currentWave, gameState.difficulty);
             gameFlow.enterSetupPhase(); // Creates instances and moves to setup
             UIController.log("【ヒント】キャラクターカードをクリックすると詳細やスキルを確認できます。", 'log-tutorial', {icon: LogIcons.tutorial});
        },
        enterSetupPhase: () => {
            // Ensure player instances are created/ready before battle
             if (!gameState.playerParty || gameState.playerParty.length !== PLAYER_PARTY_SIZE) {
                 console.log("Setup Phase: Creating player party instances...");
                 try {
                     if (!gameState.playerPartyData || gameState.playerPartyData.length !== PLAYER_PARTY_SIZE) {
                         throw new Error("Party data is incomplete.");
                     }
                     // Create fresh instances for the battle run
                     partyMemberCounter = 0; // Reset counter if needed, or manage IDs differently
                     gameState.playerParty = gameState.playerPartyData.map((pData, index) => {
                         const baseData = CharacterDatabase[pData.baseId];
                         if (!baseData) throw new Error(`Base data not found for ${pData.baseId}`);
                         const skills = pData.skills.map(id => SkillDatabase[id]).filter(Boolean); // Map IDs back to objects
                         const boostedStats = pData.boostedStats || { hp: 0, atk: 0, def: 0 };
                         // Use existing uniqueId if available, otherwise generate new one
                         const uniqueId = pData.uniqueId || `p-uuid-${partyMemberCounter++}`;
                         pData.uniqueId = uniqueId; // Ensure playerPartyData also has the ID
                         return new Character(baseData, 'player', pData.level, skills, uniqueId, AIType.NORMAL, boostedStats);
                     });
                     console.log("Player party instances created for battle:", gameState.playerParty.map(p=>p.uniqueId));
                 } catch (error) {
                     console.error("Critical error: Cannot prepare for battle. Returning to Hub.", error);
                     alert("戦闘準備に失敗しました。拠点に戻ります。");
                     gameFlow.returnToHub();
                     return;
                 }
             }

            // Ensure opponents are ready
            if (!gameState.opponentParty || gameState.opponentParty.length === 0) {
                gameState.opponentParty = generateOpponentParty(gameState.currentWave, gameState.difficulty);
                if (!gameState.opponentParty || gameState.opponentParty.length === 0) {
                    console.error("Critical error: Failed to generate opponents. Returning to Hub.");
                    alert("敵の生成に失敗しました。拠点に戻ります。");
                    gameFlow.returnToHub();
                    return;
                }
            }
            // Create Battle Manager with live instances
            gameState.battleManager = new BattleManager(gameState.playerParty, gameState.opponentParty);
            UIController.switchScreen(GamePhase.SETUP); // Show setup screen
            UIController.setupSetupPhaseUI(gameState.currentWave, gameState.opponentParty, gameState.playerParty); // Display enemy info
            UIController.updateGameInfo(); // Update header
            UIController.updatePartyInfoSidebar(); // Show party sidebar with initial state

            // Flavor/Tutorial text
            if (gameState.currentWave % 5 === 0) { UIController.log(`魔塔の${gameState.currentWave}階層...空気が重くなるのを感じる。`, 'log-flavor', {icon: LogIcons.flavor}); }
            if (gameState.currentWave === 2) { UIController.log("【ヒント】敵の特性や弱点を突くと戦闘が有利になります。", 'log-tutorial', {icon: LogIcons.tutorial}); }
            if (gameState.currentWave === 3) { UIController.log("【ヒント】状態異常を付与するスキルも有効です。", 'log-tutorial', {icon: LogIcons.tutorial}); }
        },
        handleEnemyDefeat: (enemyCharacter) => {
            const enemyBaseId = enemyCharacter.baseId;
            const potentialPlayerId = `p_${enemyBaseId}`; // Check if a playable version exists
            if (CharacterDatabase[potentialPlayerId] &&
                !gameState.unlockedMonsters.includes(potentialPlayerId) &&
                !gameState.summonCandidates.includes(potentialPlayerId)) {
                    if (Math.random() < SUMMON_CANDIDATE_CHANCE) {
                        gameState.summonCandidates.push(potentialPlayerId);
                        account.savePermanentData(); // Save the new candidate list
                        UIController.log(`新たな契約の可能性！ 「${CharacterDatabase[potentialPlayerId].name}」が召喚候補に追加されました。`, 'log-win', { icon: LogIcons.unlock });
                        console.log("Summon Candidates:", gameState.summonCandidates);
                    }
            }
        },
        confirmRewardAndProceed: () => {
            if(gameState.selectedReward) {
                rewardSystem.applyReward(gameState.selectedReward);
                UIController.hideRewardModal();
                setTimeout(() => {
                    gameFlow.prepareNextWaveAfterReward();
                }, 300); // Short delay after hiding modal
            }
        },
        prepareNextWaveAfterReward: () => {
            if (gameState.battleManager) {
                gameState.battleManager.decrementTemporaryBuffsDuration(); // Update buff durations
            }
            gameState.currentWave++; // Increment wave count

            // Heal party members
            const baseHealPercent = 0.30;
            const healMultiplier = account.getAccountLevelBonus('waveHealMultiplier');
            const healPercent = baseHealPercent * healMultiplier;
            UIController.log(`階層クリアボーナス: HP ${Math.round(healPercent * 100)}% 回復`, 'log-heal', { icon: LogIcons.heal });
            gameState.playerParty.forEach(p => {
                if(p.isAlive()) {
                    const healAmount = Math.floor(p.maxHp * healPercent);
                    p.heal(healAmount, null, false); // Heal without popup
                }
                p.nextSkillIndex = 0; // Reset skill cycle
                p.recalculateStats(); // Recalculate stats in case of level ups or boosts
                p.updateDisplay(); // Update card display
            });

            gameFlow.updatePlayerPartyData(); // Sync playerParty instances back to playerPartyData
            Utils.saveGame(); // Save progress

            // Generate next opponents and move to setup
            gameState.opponentParty = generateOpponentParty(gameState.currentWave, gameState.difficulty);
            gameFlow.enterSetupPhase();
        },
        retireRun: () => {
            UIController.hideRewardModal(); // Ensure modal is hidden
            const finalFloor = gameState.currentWave - 1; // Last completed floor
            UIController.log(`--- 魔塔から帰還 (到達階層: ${finalFloor}) ---`, 'log-system', { icon: LogIcons.retire });
            gameState.isGameOver = true; // Treat retirement like a game over for flow control
            gameState.isBattleEnded = true; // Stop any potential battle processes

            // Calculate and award bonuses
            const currentTotalExpInRun = gameState.playerTotalExpInRun;
            const currentTotalStonesInRun = gameState.playerTotalStonesInRun;
            const retireBonusExp = Math.floor(currentTotalExpInRun * RETIRE_EXP_RATE);
            const retireBonusStones = Math.floor(currentTotalStonesInRun * RETIRE_STONE_RATE);
            UIController.log(`帰還ボーナスとして ${Utils.formatNumber(retireBonusExp)} 魂片 と ${Utils.formatNumber(retireBonusStones)} 魔石 を持ち帰ります。`, 'log-info', {icon: LogIcons.reward});
            account.addExperience(retireBonusExp);
            account.addMagicStones(retireBonusStones);

            // Update highest floor if needed
            if (finalFloor > gameState.highestFloor) {
                gameState.highestFloor = finalFloor;
                UIController.log(`最高到達階層を更新！: ${gameState.highestFloor}階`, 'log-win', { icon: '👑'});
            }

            account.savePermanentData(); // Save account progress
            Utils.deleteSaveData(); // Delete in-run save data

            // Show result screen
            UIController.setupResultScreen(true); // True indicates retirement
            UIController.switchScreen(GamePhase.RESULT);
        },
        handleGameOver: () => {
            if (gameState.isGameOver) return; // Prevent multiple calls
            const finalFloor = gameState.currentWave -1; // Last completed or failed floor
            console.log("handleGameOver called for floor:", finalFloor);
            UIController.log(`--- 挑戦失敗 (到達階層: ${finalFloor}) ---`, 'log-lose', {icon: LogIcons.lose});
            gameState.isGameOver = true;
            gameState.isBattleEnded = true;

            // Calculate and award bonuses
            const currentTotalExpInRun = gameState.playerTotalExpInRun;
            const currentTotalStonesInRun = gameState.playerTotalStonesInRun;
            const gameOverBonusExp = Math.floor(currentTotalExpInRun * GAMEOVER_EXP_RATE);
            const gameOverBonusStones = Math.floor(currentTotalStonesInRun * GAMEOVER_STONE_RATE);
            UIController.log(`敗北したが、${Utils.formatNumber(gameOverBonusExp)} 魂片 と ${Utils.formatNumber(gameOverBonusStones)} 魔石 を持ち帰る...`, 'log-info', {icon: LogIcons.reward});
            account.addExperience(gameOverBonusExp);
            account.addMagicStones(gameOverBonusStones);

            // Update highest floor if needed
            if (finalFloor > gameState.highestFloor) {
                gameState.highestFloor = finalFloor;
                UIController.log(`最高到達階層を更新！: ${gameState.highestFloor}階`, 'log-win', { icon: '👑'});
            }

            account.savePermanentData(); // Save account progress
            Utils.deleteSaveData(); // Delete in-run save data

            // Show result screen
            UIController.setupResultScreen(false); // False indicates game over, not retirement
            UIController.switchScreen(GamePhase.RESULT);
        },
        restartGame: (showTitle = true) => {
            // Reset game state variables thoroughly
            gameState.isGameOver = false;
            gameState.isBattleEnded = false;
            if (gameState.battleManager) {
                gameState.battleManager.isBattleEnded = true; // Ensure battle manager stops
                gameState.battleManager = null;
            }
            gameState.playerParty = [];
            gameState.opponentParty = [];
            gameState.playerPartyData = [];
            gameState.currentWave = 1;
            gameState.playerTotalExpInRun = 0;
            gameState.playerTotalStonesInRun = 0;
            gameState.temporaryBuffs = {};
            gameState.selectedReward = null;
            gameState.selectedCharacterId = null; // Clear selection

            UIController.clearLog(); // Clear log messages

            if (showTitle) {
                account.loadPermanentData(); // Reload permanent data for title screen display
                UIController.setupTitleScreen(); // Setup title screen elements
                UIController.switchScreen(GamePhase.TITLE); // Show title screen
                UIController.updateGameInfo(); // Update header (though likely hidden on title)
            } else {
                // If not showing title, directly start a new game (e.g., from retry button)
                gameFlow.startNewGame();
            }
        },
        updatePlayerPartyData: () => {
            // Syncs the state from live Character instances back to the serializable playerPartyData
            if (!gameState.playerParty || gameState.playerParty.length === 0) return;
            gameState.playerPartyData = gameState.playerParty.map(p => ({
                baseId: p.baseId,
                level: p.level,
                // Ensure skills are saved by ID
                skills: p.skills.map(s => s.id || Object.keys(SkillDatabase).find(key => SkillDatabase[key] === s)).filter(Boolean),
                uniqueId: p.uniqueId,
                boostedStats: { ...p.boostedStats } // Save current boosts
            }));
             // Recalculate average party level based on updated data
             if (gameState.playerPartyData.length === PLAYER_PARTY_SIZE) {
                 gameState.playerPartyLevel = Math.max(1, Math.floor(gameState.playerPartyData.reduce((sum, p) => sum + p.level, 0) / PLAYER_PARTY_SIZE));
             }
             UIController.updateGameInfo(); // Update header info if needed
        }
     }; // gameFlow End

    // --- Game Start ---
    document.addEventListener('DOMContentLoaded', gameFlow.initialize);

    </script>
</body>
</html>
